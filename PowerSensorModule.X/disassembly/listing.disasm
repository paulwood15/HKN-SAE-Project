Disassembly Listing for PowerSensorModule
Generated From:
C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/dist/default/production/PowerSensorModule.X.production.elf
Aug 7, 2019 4:48:45 PM

---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/traps.c  -------
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
52:                #define ERROR_HANDLER_NORETURN ERROR_HANDLER __attribute__((noreturn))
53:                #define FAILSAFE_STACK_GUARDSIZE 8
54:                
55:                /**
56:                 * a private place to store the error code if we run into a severe error
57:                 */
58:                static uint16_t TRAPS_error_code = -1;
59:                
60:                /**
61:                 * Halts 
62:                 * 
63:                 * @param code error code
64:                 */
65:                void __attribute__((naked, noreturn, weak)) TRAPS_halt_on_error(uint16_t code)
66:                {
000744  780F00     MOV W0, [W14]
67:                    TRAPS_error_code = code;
000746  78009E     MOV [W14], W1
000748  888361     MOV W1, 0x106C
68:                #ifdef __DEBUG    
69:                    __builtin_software_breakpoint();
70:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
71:                #endif
72:                    while(1);
00074A  37FFFF     BRA .L2
73:                    
74:                }
75:                
76:                /**
77:                 * Sets the stack pointer to a backup area of memory, in case we run into
78:                 * a stack error (in which case we can't really trust the stack pointer)
79:                 */
80:                inline static void use_failsafe_stack(void)
81:                {
00074C  FA0000     LNK #0x0
82:                    static uint8_t failsafe_stack[32];
83:                    asm volatile (
00074E  2104C0     MOV #0x104C, W0
000750  780780     MOV W0, W15
84:                        "   mov    %[pstack], W15\n"
85:                        :
86:                        : [pstack]"r"(failsafe_stack)
87:                    );
88:                /* Controls where the stack pointer limit is, relative to the end of the
89:                 * failsafe stack
90:                 */    
91:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
000752  210640     MOV #0x1064, W0
000754  880100     MOV W0, SPLIM
92:                            - FAILSAFE_STACK_GUARDSIZE);
93:                }
000756  FA8000     ULNK
000758  060000     RETURN
94:                
95:                
96:                /** Oscillator Fail Trap vector**/
97:                void ERROR_HANDLER_NORETURN _OscillatorFail(void)
98:                {
0002FA  F80036     PUSH RCOUNT
99:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
0002FC  A928C0     BCLR INTCON1, #1
100:                   TRAPS_halt_on_error(TRAPS_OSC_FAIL);
0002FE  EB0000     CLR W0
000300  070221     RCALL TRAPS_halt_on_error
101:               }
102:               /** Stack Error Trap Vector**/
103:               void ERROR_HANDLER_NORETURN _StackError(void)
104:               {
000302  F80036     PUSH RCOUNT
105:                   /* We use a failsafe stack: the presence of a stack-pointer error
106:                    * means that we cannot trust the stack to operate correctly unless
107:                    * we set the stack pointer to a safe place.
108:                    */
109:                   use_failsafe_stack(); 
000304  070223     RCALL _use_failsafe_stack, .LFE0, .LFB1
110:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
000306  A948C0     BCLR INTCON1, #2
111:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
000308  200010     MOV #0x1, W0
00030A  07021C     RCALL TRAPS_halt_on_error
112:               }
113:               /** Address error Trap vector**/
114:               void ERROR_HANDLER_NORETURN _AddressError(void)
115:               {
00030C  F80036     PUSH RCOUNT
116:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
00030E  A968C0     BCLR INTCON1, #3
117:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
000310  200020     MOV #0x2, W0
000312  070218     RCALL TRAPS_halt_on_error
118:               }
119:               /** Math Error Trap vector**/
120:               void ERROR_HANDLER_NORETURN _MathError(void)
121:               {
000314  F80036     PUSH RCOUNT
122:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
000316  A988C0     BCLR INTCON1, #4
123:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
000318  200030     MOV #0x3, W0
00031A  070214     RCALL TRAPS_halt_on_error
124:               }
125:               /** DMAC Error Trap vector**/
126:               void ERROR_HANDLER_NORETURN _DMACError(void)
127:               {
00031C  F80036     PUSH RCOUNT
128:                   INTCON1bits.DMACERR = 0;  //Clear the trap flag
00031E  A9A8C0     BCLR INTCON1, #5
129:                   TRAPS_halt_on_error(TRAPS_DMAC_ERR);
000320  200040     MOV #0x4, W0
000322  070210     RCALL TRAPS_halt_on_error
130:               }
131:               /** Generic Hard Trap vector**/
132:               void ERROR_HANDLER_NORETURN _HardTrapError(void)
133:               {
000324  F80036     PUSH RCOUNT
134:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
000326  A908C6     BCLR INTCON4, #0
135:                   TRAPS_halt_on_error(TRAPS_HARD_ERR);
000328  200070     MOV #0x7, W0
00032A  07020C     RCALL TRAPS_halt_on_error
136:               }
137:               /** Generic Soft Trap vector**/
138:               void ERROR_HANDLER_NORETURN _SoftTrapError(void)
139:               {
00032C  F80036     PUSH RCOUNT
140:                   INTCON3bits.DOOVR = 0;  //Clear the trap flag
00032E  A988C4     BCLR INTCON3, #4
141:                   TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
000330  2000A0     MOV #0xA, W0
000332  070208     RCALL TRAPS_halt_on_error
142:               }
143:               
144:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/tmr3.c  --------
1:                 
2:                 /**
3:                   TMR3 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr3.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR3 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR3. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <stdio.h>
51:                #include "tmr3.h"
52:                
53:                /**
54:                 Section: File specific functions
55:                */
56:                
57:                /**
58:                  Section: Data Type Definitions
59:                */
60:                
61:                /** TMR Driver Hardware Instance Object
62:                
63:                  @Summary
64:                    Defines the object required for the maintenance of the hardware instance.
65:                
66:                  @Description
67:                    This defines the object required for the maintenance of the hardware
68:                    instance. This object exists once per hardware instance of the peripheral.
69:                
70:                  Remarks:
71:                    None.
72:                */
73:                
74:                typedef struct _TMR_OBJ_STRUCT
75:                {
76:                    /* Timer Elapsed */
77:                    volatile bool           timerElapsed;
78:                    /*Software Counter value*/
79:                    volatile uint8_t        count;
80:                
81:                } TMR_OBJ;
82:                
83:                static TMR_OBJ tmr3_obj;
84:                
85:                /**
86:                  Section: Driver Interface
87:                */
88:                
89:                void TMR3_Initialize (void)
90:                {
00058C  FA0000     LNK #0x0
91:                    //TMR3 0; 
92:                    TMR3 = 0x00;
00058E  EF210A     CLR TMR3
93:                    //Period = 0.0019972863 s; Frequency = 3685000 Hz; PR3 114; 
94:                    PR3 = 0x72;
000590  200720     MOV #0x72, W0
000592  880870     MOV W0, PR3
95:                    //TCKPS 1:64; TON enabled; TSIDL disabled; TCS FOSC/2; TGATE disabled; 
96:                    T3CON = 0x8020;
000594  280200     MOV #0x8020, W0
000596  880890     MOV W0, T3CON
97:                
98:                	
99:                    tmr3_obj.timerElapsed = false;
000598  EF706E     CLR.B tmr3_obj
100:               
101:               }
00059A  FA8000     ULNK
00059C  060000     RETURN
102:               
103:               
104:               void TMR3_Tasks_16BitOperation( void )
105:               {
00059E  FA0000     LNK #0x0
106:                   /* Check if the Timer Interrupt/Status is set */
107:                   if(IFS0bits.T3IF)
0005A0  804001     MOV IFS0, W1
0005A2  201000     MOV #0x100, W0
0005A4  608000     AND W1, W0, W0
0005A6  E00000     CP0 W0
0005A8  320006     BRA Z, .L2
108:                   {
109:                       tmr3_obj.count++;
0005AA  BFD06F     MOV.B 0x106F, WREG
0005AC  E84000     INC.B W0, W0
0005AE  B7F06F     MOV.B WREG, 0x106F
110:                       tmr3_obj.timerElapsed = true;
0005B0  B3C010     MOV.B #0x1, W0
0005B2  B7F06E     MOV.B WREG, tmr3_obj
111:                       IFS0bits.T3IF = false;
0005B4  A90801     BCLR 0x801, #0
112:                   }
113:               }
0005B6  FA8000     ULNK
0005B8  060000     RETURN
114:               
115:               void TMR3_Period16BitSet( uint16_t value )
116:               {
0005BA  FA0002     LNK #0x2
0005BC  780F00     MOV W0, [W14]
117:                   /* Update the counter values */
118:                   PR3 = value;
0005BE  78009E     MOV [W14], W1
0005C0  880871     MOV W1, PR3
119:                   /* Reset the status information */
120:                   tmr3_obj.timerElapsed = false;
0005C2  EF706E     CLR.B tmr3_obj
121:               }
0005C4  FA8000     ULNK
0005C6  060000     RETURN
122:               
123:               uint16_t TMR3_Period16BitGet( void )
124:               {
0005C8  FA0000     LNK #0x0
125:                   return( PR3 );
0005CA  800870     MOV PR3, W0
126:               }
0005CC  FA8000     ULNK
0005CE  060000     RETURN
127:               
128:               void TMR3_Counter16BitSet ( uint16_t value )
129:               {
0005D0  FA0002     LNK #0x2
0005D2  780F00     MOV W0, [W14]
130:                   /* Update the counter values */
131:                   TMR3 = value;
0005D4  78009E     MOV [W14], W1
0005D6  880851     MOV W1, TMR3
132:                   /* Reset the status information */
133:                   tmr3_obj.timerElapsed = false;
0005D8  EF706E     CLR.B tmr3_obj
134:               }
0005DA  FA8000     ULNK
0005DC  060000     RETURN
135:               
136:               uint16_t TMR3_Counter16BitGet( void )
137:               {
0005DE  FA0000     LNK #0x0
138:                   return( TMR3 );
0005E0  800850     MOV TMR3, W0
139:               }
0005E2  FA8000     ULNK
0005E4  060000     RETURN
140:               
141:               
142:               
143:               
144:               void TMR3_Start( void )
145:               {
0005E6  FA0000     LNK #0x0
146:                   /* Reset the status information */
147:                   tmr3_obj.timerElapsed = false;
0005E8  EF706E     CLR.B tmr3_obj
148:               
149:               
150:                   /* Start the Timer */
151:                   T3CONbits.TON = 1;
0005EA  A8E113     BSET 0x113, #7
152:               }
0005EC  FA8000     ULNK
0005EE  060000     RETURN
153:               
154:               void TMR3_Stop( void )
155:               {
0005F0  FA0000     LNK #0x0
156:                   /* Stop the Timer */
157:                   T3CONbits.TON = false;
0005F2  A9E113     BCLR 0x113, #7
158:               
159:               }
0005F4  FA8000     ULNK
0005F6  060000     RETURN
160:               
161:               bool TMR3_GetElapsedThenClear(void)
162:               {
0005F8  FA0002     LNK #0x2
163:                   bool status;
164:                   
165:                   status = tmr3_obj.timerElapsed;
0005FA  2106E1     MOV #0x106E, W1
0005FC  784091     MOV.B [W1], W1
0005FE  784F01     MOV.B W1, [W14]
166:               
167:                   if(status == true)
000600  78401E     MOV.B [W14], W0
000602  E00400     CP0.B W0
000604  320001     BRA Z, .L11
168:                   {
169:                       tmr3_obj.timerElapsed = false;
000606  EF706E     CLR.B tmr3_obj
170:                   }
171:                   return status;
000608  78401E     MOV.B [W14], W0
172:               }
00060A  FA8000     ULNK
00060C  060000     RETURN
173:               
174:               int TMR3_SoftwareCounterGet(void)
175:               {
00060E  FA0000     LNK #0x0
176:                   return tmr3_obj.count;
000610  BFD06F     MOV.B 0x106F, WREG
000612  FB8000     ZE W0, W0
177:               }
000614  FA8000     ULNK
000616  060000     RETURN
178:               
179:               void TMR3_SoftwareCounterClear(void)
180:               {
000618  FA0000     LNK #0x0
181:                   tmr3_obj.count = 0; 
00061A  EF706F     CLR.B 0x106F
182:               }
00061C  FA8000     ULNK
00061E  060000     RETURN
183:               
184:               /**
185:                End of File
186:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/system.h  ------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the system.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "xc.h"
46:                #include "stdint.h"
47:                #include "system_types.h"
48:                
49:                #ifndef SYSTEM_H
50:                #define	SYSTEM_H
51:                /**
52:                 * Initializes the CPU core control register.
53:                 * @example
54:                 * <code>
55:                 * SYSTEM_CORCONInitialize();
56:                 * </code>
57:                 */
58:                inline static void SYSTEM_CORCONInitialize()
59:                {
60:                    CORCON = (CORCON & 0x00F2) | CORCON_MODE_PORVALUES;    // POR value
61:                }
62:                
63:                /**
64:                 * Sets the CPU core control register operating mode to a value that is decided by the
65:                 * SYSTEM_CORCON_MODES argument.
66:                 * @param modeValue SYSTEM_CORCON_MODES initialization mode specifier
67:                 * @example
68:                 * <code>
69:                 * SYSTEM_CORCONModeOperatingSet(CORCON_MODE_ENABLEALLSATNORMAL_ROUNDUNBIASED);
70:                 * </code>
71:                 */
72:                inline static void SYSTEM_CORCONModeOperatingSet(SYSTEM_CORCON_MODES modeValue)
73:                {
0006A6  FA0002     LNK #0x2
0006A8  780F00     MOV W0, [W14]
74:                    CORCON = (CORCON & 0x00F2) | modeValue;
0006AA  800221     MOV CORCON, W1
0006AC  200F20     MOV #0xF2, W0
0006AE  608000     AND W1, W0, W0
0006B0  70001E     IOR W0, [W14], W0
0006B2  880220     MOV W0, CORCON
75:                }
0006B4  FA8000     ULNK
0006B6  060000     RETURN
76:                
77:                /**
78:                 * Sets the value of CPU core control register.
79:                 * @param value value that needs to be written to the CPU core control register
80:                 * @example
81:                 * <code>
82:                 *  SYSTEM_CORCONRegisterValueSet(0x00E2);
83:                 * </code>
84:                 */
85:                inline static void SYSTEM_CORCONRegisterValueSet(uint16_t value)
86:                {
87:                    CORCON = value;
88:                }
89:                
90:                /**
91:                 * Gets the value of CPU core control register.
92:                 * @return value of the CPU core control register
93:                 * @example
94:                 * <code>
95:                 * corconSave = SYSTEM_CORCONRegisterValueGet();
96:                 * </code>
97:                 */
98:                inline static uint16_t SYSTEM_CORCONRegisterValueGet(void)
99:                {    
100:                   return CORCON;
101:               }
102:               
103:               
104:               /**
105:                * Gets the base address of the DEVID register for the currently selected device
106:                * @return base address of the DEVID register
107:                * @example
108:                * <code>
109:                * uint32_t devIdAddress;
110:                * devIdAddress = SYSTEM_DeviceIdRegisterAddressGet();
111:                * </code>
112:                */
113:               inline static uint32_t SYSTEM_DeviceIdRegisterAddressGet(void)
114:               {
115:                   return __DEVID_BASE;
116:               }
117:               
118:               /**
119:                * @Param
120:                   none
121:                * @Returns
122:                   none
123:                * @Description
124:                   Initializes the device to the default states configured in the
125:                *                  MCC GUI
126:                * @Example
127:                   SYSTEM_Initialize(void);
128:                */
129:               void SYSTEM_Initialize(void);
130:               #endif	/* SYSTEM_H */
131:               /**
132:                End of File
133:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/system.c  ------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "pin_manager.h"
46:                #include "clock.h"
47:                #include "system.h"
48:                #include "system_types.h"
49:                #include "interrupt_manager.h"
50:                #include "traps.h"
51:                #include "adc1.h"
52:                #include "tmr3.h"
53:                
54:                void SYSTEM_Initialize(void)
55:                {
0006C4  FA0000     LNK #0x0
56:                    PIN_MANAGER_Initialize();
0006C6  070009     RCALL PIN_MANAGER_Initialize
57:                    INTERRUPT_Initialize();
0006C8  070048     RCALL INTERRUPT_Initialize
58:                    CLOCK_Initialize();
0006CA  07FFCF     RCALL CLOCK_Initialize
59:                    ADC1_Initialize();
0006CC  07FFA9     RCALL ADC1_Initialize
60:                    TMR3_Initialize();
0006CE  07FF5E     RCALL TMR3_Initialize
61:                    INTERRUPT_GlobalEnable();
0006D0  07FFF3     RCALL _INTERRUPT_GlobalEnable, .LFE1, .LFB5
62:                    SYSTEM_CORCONModeOperatingSet(CORCON_MODE_PORVALUES);
0006D2  200200     MOV #0x20, W0
0006D4  07FFE8     RCALL _SYSTEM_CORCONModeOperatingSet, .Ltext0, .LFB1, .Letext0, .LFE0
63:                }
0006D6  FA8000     ULNK
0006D8  060000     RETURN
64:                
65:                /**
66:                 End of File
67:                */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/reset.c  -------
1:                 /**
2:                   RESET Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     reset.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the RESET driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for RESET.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdbool.h>
46:                #include <stdint.h>
47:                #include "xc.h"
48:                #include "reset.h"
49:                
50:                /**
51:                 Section: Local Variables
52:                */
53:                
54:                /**
55:                 Section: Function prototypes
56:                */
57:                static bool RESET_CauseFromSoftware(uint16_t resetCause);
58:                static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause);
59:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause);
60:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause);
61:                static bool RESET_CauseFromExternal(uint16_t resetCause);
62:                static bool RESET_CauseFromTrap(uint16_t resetCause);
63:                static void RESET_CauseClear(RESET_MASKS resetFlagMask);
64:                
65:                uint16_t RESET_GetCause(void)
66:                {
00039C  FA0000     LNK #0x0
67:                    return RCON;
00039E  803A00     MOV RCON, W0
68:                }
0003A0  FA8000     ULNK
0003A2  060000     RETURN
69:                
70:                void __attribute__ ((weak)) RESET_CauseHandler(void)
71:                {
0003A4  FA0002     LNK #0x2
72:                    uint16_t resetCause = RESET_GetCause();
0003A6  07FFFA     RCALL RESET_GetCause
0003A8  780F00     MOV W0, [W14]
73:                    if(RESET_CauseFromTrap(resetCause))
0003AA  78001E     MOV [W14], W0
0003AC  070024     RCALL _RESET_CauseFromTrap, .LFE1, .LFB2
0003AE  E00400     CP0.B W0
0003B0  320002     BRA Z, .L3
74:                    { 
75:                      RESET_CauseClear(RESET_MASK_TRAPR); 
0003B2  280000     MOV #0x8000, W0
0003B4  070071     RCALL _RESET_CauseClear, .LFE7, .LFB8
76:                      //Do something 
77:                    }
78:                    if(RESET_CauseFromIllegalOpcode(resetCause))
0003B6  78001E     MOV [W14], W0
0003B8  07002A     RCALL _RESET_CauseFromIllegalOpcode, .LFE2, .LFB3
0003BA  E00400     CP0.B W0
0003BC  320002     BRA Z, .L4
79:                    { 
80:                      RESET_CauseClear(RESET_MASK_IOPUWR); 
0003BE  240000     MOV #0x4000, W0
0003C0  07006B     RCALL _RESET_CauseClear, .LFE7, .LFB8
81:                      //Do something 
82:                    }
83:                    if(RESET_CauseFromConfigurationMismatch(resetCause))
0003C2  78001E     MOV [W14], W0
0003C4  070032     RCALL _RESET_CauseFromConfigurationMismatch, .LFE3, .LFB4
0003C6  E00400     CP0.B W0
0003C8  320002     BRA Z, .L5
84:                    { 
85:                      RESET_CauseClear(RESET_MASK_CM); 
0003CA  202000     MOV #0x200, W0
0003CC  070065     RCALL _RESET_CauseClear, .LFE7, .LFB8
86:                      //Do something 
87:                    }
88:                    if(RESET_CauseFromExternal(resetCause))
0003CE  78001E     MOV [W14], W0
0003D0  07003A     RCALL _RESET_CauseFromExternal, .LFE4, .LFB5
0003D2  E00400     CP0.B W0
0003D4  320002     BRA Z, .L6
89:                    { 
90:                      RESET_CauseClear(RESET_MASK_EXTR); 
0003D6  200800     MOV #0x80, W0
0003D8  07005F     RCALL _RESET_CauseClear, .LFE7, .LFB8
91:                      //Do something 
92:                    }
93:                    if(RESET_CauseFromSoftware(resetCause))
0003DA  78001E     MOV [W14], W0
0003DC  070042     RCALL _RESET_CauseFromSoftware, .LFE5, .LFB6
0003DE  E00400     CP0.B W0
0003E0  320002     BRA Z, .L7
94:                    { 
95:                      RESET_CauseClear(RESET_MASK_SWR); 
0003E2  200400     MOV #0x40, W0
0003E4  070059     RCALL _RESET_CauseClear, .LFE7, .LFB8
96:                      //Do something 
97:                    }
98:                    if(RESET_CauseFromWatchdogTimer(resetCause))
0003E6  78001E     MOV [W14], W0
0003E8  07004A     RCALL _RESET_CauseFromWatchdogTimer, .LFE6, .LFB7
0003EA  E00400     CP0.B W0
0003EC  320002     BRA Z, .L2
99:                    { 
100:                     RESET_CauseClear(RESET_MASK_WDTO); 
0003EE  200100     MOV #0x10, W0
0003F0  070053     RCALL _RESET_CauseClear, .LFE7, .LFB8
101:                     //Do something 
102:                   }
103:               }
0003F2  FA8000     ULNK
0003F4  060000     RETURN
104:               
105:               static bool RESET_CauseFromTrap(uint16_t resetCause)
106:               {
0003F6  FA0004     LNK #0x4
0003F8  980710     MOV W0, [W14+2]
107:                   bool resetStatus = false;
0003FA  EB4000     CLR.B W0
0003FC  784F00     MOV.B W0, [W14]
108:                   if(resetCause & RESET_MASK_TRAPR)
0003FE  90001E     MOV [W14+2], W0
000400  E00000     CP0 W0
000402  3D0002     BRA GE, .L10
109:                   { 
110:                     resetStatus = true; 
000404  B3C010     MOV.B #0x1, W0
000406  784F00     MOV.B W0, [W14]
111:                   }
112:                   return resetStatus;
000408  78401E     MOV.B [W14], W0
113:               }
00040A  FA8000     ULNK
00040C  060000     RETURN
114:               
115:               static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
116:               {
00040E  FA0004     LNK #0x4
000410  980710     MOV W0, [W14+2]
117:                   bool resetStatus = false;
000412  EB4000     CLR.B W0
000414  784F00     MOV.B W0, [W14]
118:                   if(resetCause & RESET_MASK_IOPUWR)
000416  90009E     MOV [W14+2], W1
000418  240000     MOV #0x4000, W0
00041A  608000     AND W1, W0, W0
00041C  E00000     CP0 W0
00041E  320002     BRA Z, .L12
119:                   { 
120:                     resetStatus = true; 
000420  B3C010     MOV.B #0x1, W0
000422  784F00     MOV.B W0, [W14]
121:                   }
122:                   return resetStatus;
000424  78401E     MOV.B [W14], W0
123:               }
000426  FA8000     ULNK
000428  060000     RETURN
124:               
125:               static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
126:               {
00042A  FA0004     LNK #0x4
00042C  980710     MOV W0, [W14+2]
127:                   bool resetStatus = false;
00042E  EB4000     CLR.B W0
000430  784F00     MOV.B W0, [W14]
128:                   if(resetCause & RESET_MASK_CM)
000432  90009E     MOV [W14+2], W1
000434  202000     MOV #0x200, W0
000436  608000     AND W1, W0, W0
000438  E00000     CP0 W0
00043A  320002     BRA Z, .L14
129:                   { 
130:                     resetStatus = true; 
00043C  B3C010     MOV.B #0x1, W0
00043E  784F00     MOV.B W0, [W14]
131:                   }
132:                   return resetStatus;
000440  78401E     MOV.B [W14], W0
133:               }
000442  FA8000     ULNK
000444  060000     RETURN
134:               
135:               static bool RESET_CauseFromExternal(uint16_t resetCause)
136:               {
000446  FA0004     LNK #0x4
000448  980710     MOV W0, [W14+2]
137:                   bool resetStatus = false;
00044A  EB4000     CLR.B W0
00044C  784F00     MOV.B W0, [W14]
138:                   if(resetCause & RESET_MASK_EXTR)
00044E  90009E     MOV [W14+2], W1
000450  200800     MOV #0x80, W0
000452  608000     AND W1, W0, W0
000454  E00000     CP0 W0
000456  320002     BRA Z, .L16
139:                   { 
140:                     resetStatus = true; 
000458  B3C010     MOV.B #0x1, W0
00045A  784F00     MOV.B W0, [W14]
141:                   }
142:                   return resetStatus;
00045C  78401E     MOV.B [W14], W0
143:               }
00045E  FA8000     ULNK
000460  060000     RETURN
144:               
145:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
146:               {
000462  FA0004     LNK #0x4
000464  980710     MOV W0, [W14+2]
147:                   bool resetStatus = false;
000466  EB4000     CLR.B W0
000468  784F00     MOV.B W0, [W14]
148:                   if(resetCause & RESET_MASK_SWR)
00046A  90009E     MOV [W14+2], W1
00046C  200400     MOV #0x40, W0
00046E  608000     AND W1, W0, W0
000470  E00000     CP0 W0
000472  320002     BRA Z, .L18
149:                   { 
150:                     resetStatus = true; 
000474  B3C010     MOV.B #0x1, W0
000476  784F00     MOV.B W0, [W14]
151:                   }
152:                   return resetStatus;
000478  78401E     MOV.B [W14], W0
153:               }
00047A  FA8000     ULNK
00047C  060000     RETURN
154:               
155:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
156:               {
00047E  FA0004     LNK #0x4
000480  980710     MOV W0, [W14+2]
157:                   bool resetStatus = false;
000482  EB4000     CLR.B W0
000484  784F00     MOV.B W0, [W14]
158:                   if(resetCause & RESET_MASK_WDTO)
000486  90001E     MOV [W14+2], W0
000488  600070     AND W0, #0x10, W0
00048A  E00000     CP0 W0
00048C  320002     BRA Z, .L20
159:                   { 
160:                     resetStatus = true;
00048E  B3C010     MOV.B #0x1, W0
000490  784F00     MOV.B W0, [W14]
161:                   }
162:                   return resetStatus;
000492  78401E     MOV.B [W14], W0
163:               }
000494  FA8000     ULNK
000496  060000     RETURN
164:               
165:               static void RESET_CauseClear(RESET_MASKS resetFlagMask)
166:               { 
000498  FA0002     LNK #0x2
00049A  780F00     MOV W0, [W14]
167:                    RCON = RCON & (~resetFlagMask); 
00049C  EA809E     COM [W14], W1
00049E  803A00     MOV RCON, W0
0004A0  608000     AND W1, W0, W0
0004A2  883A00     MOV W0, RCON
168:               } 
0004A4  FA8000     ULNK
0004A6  060000     RETURN
169:               
170:               void RESET_CauseClearAll()
171:               { 
0004A8  FA0000     LNK #0x0
172:                   RCON = 0x00; 
0004AA  EF2740     CLR RCON
173:               }
0004AC  FA8000     ULNK
0004AE  060000     RETURN
174:               /**
175:                End of File
176:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/pin_manager.c  -
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
19:                        Device            :  dsPIC33EV32GM102
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.36B
22:                        MPLAB 	          :  MPLAB X v5.20
23:                */
24:                
25:                /*
26:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdio.h>
54:                #include "pin_manager.h"
55:                
56:                /**
57:                 Section: File specific functions
58:                */
59:                
60:                /**
61:                 Section: Driver Interface Function Definitions
62:                */
63:                void PIN_MANAGER_Initialize (void)
64:                {
0006DA  FA0000     LNK #0x0
65:                    /****************************************************************************
66:                     * Setting the Output Latch SFR(s)
67:                     ***************************************************************************/
68:                    LATA = 0x0000;
0006DC  EF2E04     CLR LATA
69:                    LATB = 0x0000;
0006DE  EF2E18     CLR LATB
70:                
71:                    /****************************************************************************
72:                     * Setting the GPIO Direction SFR(s)
73:                     ***************************************************************************/
74:                    TRISA = 0x0017;
0006E0  200170     MOV #0x17, W0
0006E2  887000     MOV W0, TRISA
75:                    TRISB = 0x0FFF;
0006E4  20FFF0     MOV #0xFFF, W0
0006E6  8870A0     MOV W0, TRISB
76:                
77:                    /****************************************************************************
78:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
79:                     ***************************************************************************/
80:                    CNPDA = 0x000D;
0006E8  2000D0     MOV #0xD, W0
0006EA  887060     MOV W0, CNPDA
81:                    CNPDB = 0x0000;
0006EC  EF2E20     CLR CNPDB
82:                    CNPUA = 0x0000;
0006EE  EF2E0A     CLR CNPUA
83:                    CNPUB = 0x0000;
0006F0  EF2E1E     CLR CNPUB
84:                
85:                    /****************************************************************************
86:                     * Setting the Open Drain SFR(s)
87:                     ***************************************************************************/
88:                    ODCA = 0x0000;
0006F2  EF2E06     CLR ODCA
89:                    ODCB = 0x0000;
0006F4  EF2E1A     CLR ODCB
90:                
91:                    /****************************************************************************
92:                     * Setting the Analog/Digital Configuration SFR(s)
93:                     ***************************************************************************/
94:                    ANSELA = 0x0010;
0006F6  200100     MOV #0x10, W0
0006F8  887070     MOV W0, ANSELA
95:                    ANSELB = 0x0383;
0006FA  203830     MOV #0x383, W0
0006FC  887110     MOV W0, ANSELB
96:                
97:                
98:                
99:                }
0006FE  FA8000     ULNK
000700  060000     RETURN
100:               
101:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/mcc.c  ---------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     mcc.c
9:                 
10:                  @Summary:
11:                    This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    //Boot Segment Write-Protect Bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    //Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSS2 = OFF    //Boot Segment Control Bit->No Boot Segment
51:                #pragma config GWRP = OFF    //General Segment Write-Protect Bit->General Segment may be written
52:                #pragma config GSS = DISABLED    //General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    //Configuration Segment Write-Protect Bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    //Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = DISABLE    //Alternate Interrupt Vector Table Disable Bit ->Disable Alternate Vector Table
56:                
57:                // FBSLIM
58:                #pragma config BSLIM = 8191    //Boot Segment Code Flash Page Address Limit Bits->8191
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCDIVN    //Initial oscillator Source Selection Bits->Internal Fast RC (FRC) Oscillator with postscaler
62:                #pragma config IESO = OFF    //Two Speed Oscillator Start-Up Bit->Start up device with user selected oscillator source
63:                
64:                // FOSC
65:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select Bits->Primary Oscillator disabled
66:                #pragma config OSCIOFNC = ON    //OSC2 Pin I/O Function Enable Bit->OSC2 is general purpose digital I/O pin
67:                #pragma config IOL1WAY = ON    //Peripheral Pin Select Configuration Bit->Allow Only One reconfiguration
68:                #pragma config FCKSM = CSECMD    //Clock Switching Mode Bits->Clock Switching is enabled,Fail-safe Clock Monitor is disabled
69:                #pragma config PLLKEN = ON    //PLL Lock Enable Bit->Clock switch to PLL source will wait until the PLL lock signal is valid
70:                
71:                // FWDT
72:                #pragma config WDTPOST = PS32768    //Watchdog Timer Postscaler Bits->1:32768
73:                #pragma config WDTPRE = PR128    //Watchdog Timer Prescaler Bit->1:128
74:                #pragma config FWDTEN = OFF    //Watchdog Timer Enable Bits->WDT and SWDTEN Disabled
75:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable Bit->Watchdog timer in Non-Window Mode
76:                #pragma config WDTWIN = WIN25    //Watchdog Window Select Bits->WDT Window is 25% of WDT period
77:                
78:                // FPOR
79:                #pragma config BOREN0 = ON    //Brown Out Reset Detection Bit->BOR is Enabled
80:                
81:                // FICD
82:                #pragma config ICS = PGD1    //ICD Communication Channel Select Bits->Communicate on PGEC1 and PGED1
83:                
84:                // FDMTINTVL
85:                #pragma config DMTIVTL = 0    //Lower 16 Bits of 32 Bit DMT Window Interval->0
86:                
87:                // FDMTINTVH
88:                #pragma config DMTIVTH = 0    //Upper 16 Bits of 32 Bit DMT Window Interval->0
89:                
90:                // FDMTCNTL
91:                #pragma config DMTCNTL = 0    //Lower 16 Bits of 32 Bit DMT Instruction Count Time-Out Value->0
92:                
93:                // FDMTCNTH
94:                #pragma config DMTCNTH = 0    //Upper 16 Bits of 32 Bit DMT Instruction Count Time-Out Value->0
95:                
96:                // FDMT
97:                #pragma config DMTEN = DISABLE    //Dead Man Timer Enable Bit->Dead Man Timer is Disabled and can be enabled by software
98:                
99:                // FDEVOPT
100:               #pragma config PWMLOCK = ON    //PWM Lock Enable Bit->Certain PWM registers may only be written after key sequence
101:               #pragma config ALTI2C1 = OFF    //Alternate I2C1 Pins Selection Bit->I2C1 mapped to SDA1/SCL1 pins
102:               
103:               // FALTREG
104:               #pragma config CTXT1 = NONE    //Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 1->Not Assigned
105:               #pragma config CTXT2 = NONE    //Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 2->Not Assigned
106:               
107:               #include "mcc.h"
108:               #include "reset.h"
109:               #include "clock.h"
110:               
111:               /**
112:                Section: Local Variables
113:               */
114:               
115:               /**
116:                Section: Function prototypes
117:               */
118:               
119:               /**
120:               * a private place to store the error code if we run into a severe error
121:               */
122:               
123:               void OSCILLATOR_Initialize(void)
124:               {
000724  FA0000     LNK #0x0
125:                   CLOCK_Initialize();
000726  07FFA1     RCALL CLOCK_Initialize
126:               }
000728  FA8000     ULNK
00072A  060000     RETURN
127:               
128:               uint16_t SYSTEM_GetResetCause(void)
129:               {
00072C  FA0000     LNK #0x0
130:                   return RCON;
00072E  803A00     MOV RCON, W0
131:               }
000730  FA8000     ULNK
000732  060000     RETURN
132:               
133:               void __attribute__ ((weak)) SYSTEM_ResetCauseHandler(void)
134:               {
000734  FA0000     LNK #0x0
135:                   RESET_CauseHandler();
000736  07FE36     RCALL RESET_CauseHandler
136:               }
000738  FA8000     ULNK
00073A  060000     RETURN
137:               
138:               void SYSTEM_ResetCauseClearAll()
139:               { 
00073C  FA0000     LNK #0x0
140:                   RESET_CauseClearAll();
00073E  07FEB4     RCALL RESET_CauseClearAll
141:               }
000740  FA8000     ULNK
000742  060000     RETURN
142:               /**
143:                End of File
144:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/interrupt_manager.h
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _INTERRUPT_MANAGER_H
46:                #define _INTERRUPT_MANAGER_H
47:                
48:                /**
49:                  @Summary
50:                    Initializes the interrupt priorities of the dsPIC33EV32GM102
51:                
52:                  @Description
53:                    This routine sets the interrupt priorities of the modules that have been configured
54:                    for the dsPIC33EV32GM102
55:                
56:                  @Preconditions
57:                    None.
58:                
59:                  @Returns
60:                    None.
61:                
62:                  @Param
63:                    None.
64:                
65:                  @Example
66:                    <code>
67:                    void SYSTEM_Initialize(void)
68:                    {
69:                        // Other initializers are called from this function
70:                        INTERRUPT_Initialize ();
71:                    }
72:                    </code>
73:                
74:                */
75:                void INTERRUPT_Initialize(void);
76:                
77:                /**
78:                  @Summary
79:                    Enables global interrupts of the dsPIC33EV32GM102
80:                
81:                  @Description
82:                    This routine enables the global interrupt bit for the dsPIC33EV32GM102
83:                
84:                  @Preconditions
85:                    None.
86:                
87:                  @Returns
88:                    None.
89:                
90:                  @Param
91:                    None.
92:                
93:                  @Example
94:                    <code>
95:                    void SYSTEM_Initialize(void)
96:                    {
97:                        // Other initializers are called from this function
98:                        INTERRUPT_GlobalEnable ();
99:                    }
100:                   </code>
101:               
102:               */
103:               inline static void INTERRUPT_GlobalEnable(void)
104:               {
0006B8  FA0000     LNK #0x0
105:                   __builtin_enable_interrupts();
0006BA  A8E8C3     BSET 0x8C3, #7
0006BC  000000     NOP
0006BE  000000     NOP
106:               }
0006C0  FA8000     ULNK
0006C2  060000     RETURN
107:               
108:               /**
109:                 @Summary
110:                   Disables global interrupts of the dsPIC33EV32GM102
111:               
112:                 @Description
113:                   This routine disables the global interrupt bit for the dsPIC33EV32GM102
114:               
115:                 @Preconditions
116:                   None.
117:               
118:                 @Returns
119:                   None.
120:               
121:                 @Param
122:                   None.
123:               
124:                 @Example
125:                   <code>
126:                   void SYSTEM_Initialize(void)
127:                   {
128:                       // Other initializers are called from this function
129:                       INTERRUPT_GlobalDisable ();
130:                   }
131:                   </code>
132:               
133:               */
134:               inline static void INTERRUPT_GlobalDisable(void)
135:               {
136:                   __builtin_disable_interrupts();
137:               }
138:               
139:               
140:               #endif
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/interrupt_manager.c
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
00075A  FA0000     LNK #0x0
55:                    //    ADI: ADC1 Convert Done
56:                    //    Priority: 1
57:                        IPC3bits.AD1IP = 1;
00075C  804231     MOV IPC3, W1
00075E  2FF8F0     MOV #0xFF8F, W0
000760  608000     AND W1, W0, W0
000762  A04000     BSET W0, #4
000764  884230     MOV W0, IPC3
58:                }
000766  FA8000     ULNK
000768  060000     RETURN
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/clock.c  -------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                
49:                void CLOCK_Initialize(void)
50:                {
00066A  FA0000     LNK #0x0
51:                    // FRCDIV FRC/1; PLLPRE 2; DOZE 1:8; PLLPOST 1:2; DOZEN disabled; ROI disabled; 
52:                    CLKDIV = 0x3000;
00066C  230000     MOV #0x3000, W0
00066E  883A20     MOV W0, CLKDIV
53:                    // TUN Center frequency; 
54:                    OSCTUN = 0x00;
000670  EF2748     CLR OSCTUN
55:                    // ROON disabled; ROSEL FOSC; RODIV 0; ROSSLP disabled; 
56:                    REFOCON = 0x00;
000672  EF274E     CLR REFOCON
57:                    // PLLDIV 50; 
58:                    PLLFBD = 0x32;
000674  200320     MOV #0x32, W0
000676  883A30     MOV W0, PLLFBD
59:                    // AD1MD enabled; PWMMD enabled; T3MD enabled; T4MD enabled; T1MD enabled; U2MD enabled; T2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; C1MD enabled; T5MD enabled; I2C1MD enabled; 
60:                    PMD1 = 0x00;
000678  EF2760     CLR PMD1
61:                    // IC4MD enabled; IC3MD enabled; OC1MD enabled; IC2MD enabled; OC2MD enabled; IC1MD enabled; OC3MD enabled; OC4MD enabled; 
62:                    PMD2 = 0x00;
00067A  EF2762     CLR PMD2
63:                    // CMPMD enabled; 
64:                    PMD3 = 0x00;
00067C  EF2764     CLR PMD3
65:                    // CTMUMD enabled; REFOMD enabled; 
66:                    PMD4 = 0x00;
00067E  EF2766     CLR PMD4
67:                    // PWM2MD enabled; PWM1MD enabled; PWM3MD enabled; 
68:                    PMD6 = 0x00;
000680  EF276A     CLR PMD6
69:                    // DMA0MD enabled; 
70:                    PMD7 = 0x00;
000682  EF276C     CLR PMD7
71:                    // DMTMD enabled; SENT2MD enabled; SENT1MD enabled; 
72:                    PMD8 = 0x00;
000684  EF276E     CLR PMD8
73:                    // CF no clock failure; NOSC FRCDIV; CLKLOCK unlocked; OSWEN Switch is Complete; 
74:                    __builtin_write_OSCCONH((uint8_t) (0x07));
000686  200072     MOV #0x7, W2
000688  200780     MOV #0x78, W0
00068A  2009A1     MOV #0x9A, W1
00068C  207433     MOV #0x743, W3
00068E  784980     MOV.B W0, [W3]
000690  784981     MOV.B W1, [W3]
000692  784982     MOV.B W2, [W3]
75:                    __builtin_write_OSCCONL((uint8_t) (0x00));
000694  EB0100     CLR W2
000696  200460     MOV #0x46, W0
000698  200571     MOV #0x57, W1
00069A  207423     MOV #0x742, W3
00069C  784980     MOV.B W0, [W3]
00069E  784981     MOV.B W1, [W3]
0006A0  784982     MOV.B W2, [W3]
76:                }
0006A2  FA8000     ULNK
0006A4  060000     RETURN
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/adc1.h  --------
1:                 /**
2:                   ADC1 Generated Driver API Header File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     adc1.h
9:                 
10:                  @Summary
11:                    This is the generated header file for the ADC1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides APIs for driver for ADC1.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB 	          :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _ADC1_H
46:                #define _ADC1_H
47:                
48:                /**
49:                  Section: Included Files
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdbool.h>
54:                #include <stdint.h>
55:                #include <stdlib.h>
56:                
57:                #ifdef __cplusplus  // Provide C++ Compatibility
58:                
59:                    extern "C" {
60:                
61:                #endif
62:                /**
63:                  Section: ISR Helper Macros
64:                */
65:                
66:                #define ADC1_ISR_FUNCTION_HEADER    void __attribute__((interrupt, no_auto_psv)) _AD1Interrupt
67:                #define ADC_BUF_SIZE 16
68:                
69:                       
70:                /**
71:                  Section: Data Types
72:                */
73:                
74:                /** ADC Channel Definition
75:                 
76:                 @Summary 
77:                   Defines the channels available for conversion
78:                 
79:                 @Description
80:                   This routine defines the channels that are available conversion.
81:                 
82:                 Remarks:
83:                   None
84:                 */
85:                typedef enum 
86:                {
87:                    ADC1_VIN =  0x2,
88:                    ADC1_IIN =  0x3,
89:                    ADC1_CHANNEL_INTERNAL_BAND_GAP_REFERENCE =  0x3D,
90:                    ADC1_CHANNEL_CTMU =  0x3E,
91:                    ADC1_MAX_CHANNEL_COUNT = 4
92:                } ADC1_CHANNEL;
93:                
94:                /** ADC Positive 123 Channels Definition
95:                 
96:                 @Summary 
97:                   Defines the positive 123 channels available for conversion
98:                 
99:                 @Description
100:                  This routine defines the positive 123 channels that are available for the 
101:                  module to use.
102:                
103:                Remarks:
104:                  None
105:                */
106:               typedef enum 
107:               {
108:                   ADC1_POS_123_CHANNEL_0 = 0x0,
109:                   ADC1_POS_123_CHANNEL_1 = 0x1,   
110:                   ADC1_POS_123_CHANNEL_2 = 0x8,
111:                   ADC1_POS_123_CHANNEL_3 = 0x9,
112:                   ADC1_POS_123_CHANNEL_4 = 0x10
113:               } ADC1_POS_123_CHANNEL;
114:               
115:               /** ADC Negative 123 Channels Definition
116:                
117:                @Summary 
118:                  Defines the negative 123 channels available for conversion
119:                
120:                @Description
121:                  This routine defines the negative 123 channels that are available for the 
122:                  module to use.
123:                
124:                Remarks:
125:                  None
126:                */
127:               typedef enum 
128:               {
129:                  ADC1_NEG_123_CHANNEL_0 = 0x0,
130:                  ADC1_NEG_123_CHANNEL_1 = 0x2,
131:                  ADC1_NEG_123_CHANNEL_2 = 0x3
132:               } ADC1_NEG_123_CHANNEL;
133:               
134:               /** ADC Data Format Type Definition
135:                
136:                @Summary 
137:                  Defines the data format types available
138:                
139:                @Description
140:                  This routine defines the data format types that are available for the module 
141:                  to use.
142:                
143:                Remarks:
144:                  None
145:                */
146:               typedef enum 
147:               {
148:                   ADC1_FORM_UNSIGNED_INT   = 0, /* Unsigned Integer */
149:                   ADC1_FORM_SIGNED_INT     = 1, /* Signed Integer */
150:                   ADC1_FORM_UNSIGNED_FRACT = 2, /* Unsigned Fraction */
151:                   ADC1_FORM_SIGNED_FRACT   = 3  /* Signed Integer */
152:               } ADC1_FORM_TYPE;
153:               
154:               /** ADC Resolution Type Definition
155:                
156:                @Summary 
157:                  Defines the resolution types available
158:                
159:                @Description
160:                  This routine defines the resolution types that are available for the module 
161:                  to use.
162:                
163:                Remarks:
164:                  None
165:                */
166:               typedef enum 
167:               {
168:                   ADC1_RESOLUTION_10_BIT   = 0, /* 10-bit, 4-channel ADC operation */
169:                   ADC1_RESOLUTION_12_BIT   = 1  /* 12-bit, 1-channel ADC operation */
170:               } ADC1_RESOLUTION_TYPE;
171:               
172:               /** ADC Sampling Source Definition
173:                
174:                @Summary 
175:                  Defines the sampling sources available
176:                
177:                @Description
178:                  This routine defines the sampling sources that are available for the module 
179:                  to use.
180:                
181:                Remarks:
182:                  None
183:                */
184:               typedef enum 
185:               {
186:                   ADC1_SAMPLING_SOURCE_PWM  =  0x3,
187:                   ADC1_SAMPLING_SOURCE_MANUAL  =  0x0,
188:                   ADC1_SAMPLING_SOURCE_AUTO  =  0x7,
189:                   ADC1_SAMPLING_SOURCE_PWM2  =  0x1,
190:                   ADC1_SAMPLING_SOURCE_CTMU  =  0x6,
191:                   ADC1_SAMPLING_SOURCE_PWM3  =  0x2,
192:                   ADC1_SAMPLING_SOURCE_TMR5  =  0x4,
193:                   ADC1_SAMPLING_SOURCE_PWM1  =  0x0,
194:                   ADC1_SAMPLING_SOURCE_INT0  =  0x1,
195:                   ADC1_SAMPLING_SOURCE_TMR3  =  0x2,
196:               } ADC1_SAMPLING_SOURCE;
197:               
198:               /** ADC Conversion Channel Type Definition
199:                
200:                @Summary 
201:                  Defines the conversion channel types available
202:                
203:                @Description
204:                  This routine defines the conversion channels types that are available for the 
205:                  module to use.
206:                
207:                Remarks:
208:                  None
209:                */
210:               typedef enum 
211:               {
212:                   ADC1_CONVERSION_CHANNELS_CH0    = 0, /* Converts only CH0 */
213:                   ADC1_CONVERSION_CHANNELS_CH01   = 1, /* Converts CH0 and CH1 */
214:                   ADC1_CONVERSION_CHANNELS_CH0123 = 2  /* Converts CH0, CH1, CH2 and CH3 */
215:               } ADC1_CONVERSION_CHANNELS_TYPE;
216:               
217:               /**
218:                 Section: Interface Routines
219:               */
220:               
221:               
222:               /**
223:                 @Summary
224:                   This function initializes ADC instance : 1
225:               
226:                 @Description
227:                   This routine initializes the ADC driver instance for : 1
228:                   index, making it ready for clients to open and use it. It also initializes any
229:                   internal data structures.
230:                   This routine must be called before any other ADC routine is called. 
231:               
232:                 @Preconditions
233:                   None.
234:               
235:                 @Param
236:                   None.
237:               
238:                 @Returns
239:                   None.
240:               
241:                 @Comment
242:                   
243:                
244:                 @Example
245:                   <code>
246:                       int conversion;
247:                       ADC1_Initialize();
248:                       ADC1_ChannelSelect(AN1_Channel);
249:                       ADC1_SamplingStart();
250:                       //Provide Delay
251:                       for(int i=0;i <1000;i++)
252:                       {
253:                       }
254:                       ADC1_SamplingStop();
255:                       while(!ADC1_IsConversionComplete())
256:                       {
257:                           ADC1_Tasks();   
258:                       }
259:                       conversion = ADC1_ConversionResultGet();
260:                   </code>
261:               
262:               */
263:               
264:               void ADC1_Initialize (void);
265:               
266:               /**
267:                 @Summary
268:                   This function gets the "adc_buffer" pointer
269:               
270:                 @Description
271:                   
272:               
273:                 @Preconditions
274:                   None.
275:               
276:                 @Param
277:                   None.
278:               
279:                 @Returns
280:                   The pointer of "adc_buffer"
281:               
282:               */
283:               uint16_t* ADC1_Get_Buffer_Ptr(void);
284:               
285:               /**
286:                 @Summary
287:                   This function gets the status of the "data_ready" variable
288:               
289:                 @Description
290:                   
291:               
292:                 @Preconditions
293:                   None.
294:               
295:                 @Param
296:                   None.
297:               
298:                 @Returns
299:                   "data_ready"
300:               
301:               */
302:               bool ADC1_Is_Data_Ready(void);
303:               
304:               
305:               /**
306:                 @Summary
307:                   This function clears "data_ready" to acknowledge that the data in the buffer
308:                   is ready.
309:               
310:                 @Description
311:                   
312:               
313:                 @Preconditions
314:                   None.
315:               
316:                 @Param
317:                   None.
318:               
319:                 @Returns
320:                   None.
321:               
322:               */
323:               void ADC1_Acknowledge_Data_Ready(void);
324:               
325:               
326:               /**
327:                 @Summary
328:                   Clears interrupt flag
329:               
330:                 @Description
331:                   This routine is used to clear the interrupt flag manually.
332:                
333:                 @Preconditions
334:                   None.
335:               
336:                 @Param
337:                   None.
338:               
339:                 @Returns
340:                   None.
341:               
342:                 @Example
343:                   Refer to ADC1_Initialize() for an example
344:               
345:               */
346:               
347:               inline static void ADC1_InterruptFlagClear(void)
348:               {
349:                  IFS0bits.AD1IF = 0;
350:               }
351:               
352:               /**
353:                 @Summary
354:                   Enables interrupts.
355:               
356:                 @Description
357:                   This routine is used to enable the ADC1 interrupt manually.
358:                
359:                 @Preconditions
360:                   None.
361:               
362:                 @Param
363:                   None.
364:               
365:                 @Returns
366:                   None.
367:               
368:                 @Example
369:                   Refer to ADC1_Initialize() for an example
370:               
371:               */
372:               
373:               inline static void ADC1_InterruptEnable(void)
374:               {  
375:                  IEC0bits.AD1IE = 1;
376:               }
377:               
378:               /**
379:                 @Summary
380:                   Disables interrupts
381:               
382:                 @Description
383:                   This routine is used to disable the ADC1 interrupt manually.
384:                
385:                 @Preconditions
386:                   None.
387:               
388:                 @Param
389:                   None.
390:               
391:                 @Returns
392:                   None.
393:               
394:                 @Example
395:                   Refer to ADC1_Initialize() for an example
396:               
397:               */
398:               
399:               inline static void ADC1_InterruptDisable(void)
400:               {
401:                  IEC0bits.AD1IE = 0;
402:               }
403:               
404:               /**
405:                 @Summary
406:                   Starts sampling manually.
407:               
408:                 @Description
409:                   This routine is used to start the sampling manually.
410:                
411:                 @Preconditions
412:                   ADC1_Initialize() function should have been called 
413:                   before calling this function.
414:               
415:                 @Param
416:                   None.
417:               
418:                 @Returns
419:                   None.
420:               
421:                 @Example
422:                   <code>
423:                       int conversion;
424:                       ADC1__Initialize();
425:                       ADC1_ChannelSelect(AN1_Channel);
426:                       ADC1_SamplingStart();
427:                       //Provide Delay
428:                       for(int i=0;i <1000;i++)
429:                       {
430:                       }
431:                       ADC1_SamplingStop();
432:                       while(!ADC1_IsConversionComplete())
433:                       {
434:                           ADC1_Tasks();   
435:                       }
436:                       conversion = ADC1_ConversionResultGet();
437:                   </code>
438:               
439:               */
440:               
441:               inline static void ADC1_SamplingStart(void)
442:               {
443:                  AD1CON1bits.SAMP = 1;
444:               }
445:               
446:               /**
447:                 @Summary
448:                   Stops sampling manually.
449:               
450:                 @Description
451:                   This routine is used to stop the sampling manually before conversion
452:                   is triggered.
453:                
454:                 @Preconditions
455:                   ADC1_Initialize() function should have been 
456:                   called before calling this function.
457:               
458:                 @Param
459:                   None.
460:               
461:                 @Returns
462:                   None.
463:               
464:                 @Example
465:                   <code>
466:                       int conversion;
467:                       ADC1__Initialize();
468:                       ADC1_ChannelSelect(AN1_Channel);
469:                       ADC1_SamplingStart();
470:                       //Provide Delay
471:                       for(int i=0;i <1000;i++)
472:                       {
473:                       }
474:                       ADC1_SamplingStop();
475:                       while(!ADC1_IsConversionComplete())
476:                       {
477:                           ADC1_Tasks();   
478:                       }
479:                       conversion = ADC1_ConversionResultGet();
480:                   </code>
481:               */
482:               
483:               inline static void ADC1_SamplingStop(void)
484:               {
485:                  AD1CON1bits.SAMP = 0;
486:               }
487:               
488:               /**
489:                 @Summary
490:                   Gets the buffer loaded with conversion results.
491:               
492:                 @Description
493:                   This routine is used to get the analog to digital converted values in a
494:                   buffer. This routine gets converted values from multiple channels.
495:                
496:                 @Preconditions
497:                   This routine returns the buffer containing the conversion values only after 
498:                   the conversion is complete. Completion status conversion can be checked using 
499:                   ADC1_IsConversionComplete() routine.
500:                
501:                 @Param
502:                   None.
503:               
504:                 @Returns
505:                   Returns the count of the buffer containing the conversion values.
506:               
507:                 @Example
508:                   <code>
509:                       int count;
510:                       //Initialize for channel scanning
511:                       ADC1_Initialize();
512:                       ADC1_SamplingStart();
513:                       //Provide Delay
514:                       for(int i=0;i <1000;i++)
515:                       {
516:                       }
517:                       ADC1_SamplingStop();
518:                       while(!ADC1_IsConversionComplete())
519:                       {
520:                           count = ADC1_ConversionResultBufferGet();
521:                       }
522:                   </code>
523:               */
524:               
525:               uint16_t ADC1_ConversionResultBufferGet(uint16_t *buffer);
526:               
527:               /**
528:                 @Summary
529:                   Returns the ADC1 conversion value for Channel 0.
530:               
531:                 @Description
532:                   This routine is used to get the analog to digital converted value. This
533:                   routine gets converted values from the channel specified.
534:                
535:                 @Preconditions
536:                   The channel required must be selected before calling this routine using
537:                   ADC1_ChannelSelect(channel). This routine returns the 
538:                   conversion value only after the conversion is complete. Completion status 
539:                   conversion can be checked using ADC1_IsConversionComplete()
540:                   routine.
541:                  
542:                 @Returns
543:                   Returns the buffer containing the conversion value.
544:               
545:                 @Param
546:                   Buffer address
547:                 
548:                 @Example
549:                   Refer to ADC1_Initialize(); for an example
550:                */
551:               
552:               inline static uint16_t ADC1_Channel0ConversionResultGet(void) 
553:               {
554:                   return ADC1BUF0;
555:               }
556:               
557:               /**
558:                 @Summary
559:                   Returns the ADC1 conversion value from Channel 1.
560:               
561:                 @Description
562:                   This routine is used to get the analog to digital converted value. This
563:                   routine gets converted values from the channel specified.
564:                
565:                 @Preconditions
566:                   The channel required must be selected before calling this routine using
567:                   ADC1_ChannelSelect(channel). This routine returns the 
568:                   conversion value only after the conversion is complete. Completion status 
569:                   conversion can be checked using ADC1_IsConversionComplete()
570:                   routine.
571:                  
572:                 @Returns
573:                   Returns the buffer containing the conversion value.
574:               
575:                 @Param
576:                   Buffer address
577:                 
578:                 @Example
579:                   Refer to ADC1_Initialize(); for an example
580:                */
581:               
582:               inline static uint16_t ADC1_Channel1ConversionResultGet(void) 
583:               {
584:                   return ADC1BUF1;
585:               }
586:               
587:               /**
588:                 @Summary
589:                   Returns the ADC1 conversion value from Channel 2.
590:               
591:                 @Description
592:                   This routine is used to get the analog to digital converted value. This
593:                   routine gets converted values from the channel specified.
594:                
595:                 @Preconditions
596:                   The channel required must be selected before calling this routine using
597:                   ADC1_ChannelSelect(channel). This routine returns the 
598:                   conversion value only after the conversion is complete. Completion status 
599:                   conversion can be checked using ADC1_IsConversionComplete()
600:                   routine.
601:                  
602:                 @Returns
603:                   Returns the buffer containing the conversion value.
604:               
605:                 @Param
606:                   Buffer address
607:                 
608:                 @Example
609:                   Refer to ADC1_Initialize(); for an example
610:                */
611:               
612:               inline static uint16_t ADC1_Channel2ConversionResultGet(void) 
613:               {
614:                   return ADC1BUF2;
615:               }
616:               
617:               /**
618:                 @Summary
619:                   Returns the ADC1 conversion value from Channel 3.
620:               
621:                 @Description
622:                   This routine is used to get the analog to digital converted value. This
623:                   routine gets converted values from the channel specified.
624:                
625:                 @Preconditions
626:                   The channel required must be selected before calling this routine using
627:                   ADC1_ChannelSelect(channel). This routine returns the 
628:                   conversion value only after the conversion is complete. Completion status 
629:                   conversion can be checked using ADC1_IsConversionComplete()
630:                   routine.
631:                  
632:                 @Returns
633:                   Returns the buffer containing the conversion value.
634:               
635:                 @Param
636:                   Buffer address
637:                 
638:                 @Example
639:                   Refer to ADC1_Initialize(); for an example
640:                */
641:               
642:               inline static uint16_t ADC1_Channel3ConversionResultGet(void) 
643:               {
644:                   return ADC1BUF3;
645:               }
646:               
647:               /**
648:                 @Summary
649:                   Returns true when the conversion is completed
650:               
651:                 @Description
652:                   This routine is used to determine if conversion is completed. This routine
653:                   returns the value of the DONE bit. When conversion is complete the routine
654:                   returns 1. It returns 0 otherwise.
655:                
656:                 @Preconditions
657:                   ADC1_Initialize() function should have been 
658:                   called before calling this function.
659:                
660:                 @Returns
661:                   Returns true if conversion is completed
662:               
663:                 @Param
664:                   None
665:                 
666:                 @Example
667:                   Refer to ADC1_Initialize(); for an example
668:                */
669:               
670:               inline static bool ADC1_IsConversionComplete( void )
671:               {
672:                   return AD1CON1bits.DONE; //Wait for conversion to complete   
673:               }
674:               
675:               /**
676:                 @Summary
677:                   Allows selection of a channel for conversion
678:               
679:                 @Description
680:                   This routine is used to select desired channel for conversion.
681:                 
682:                 @Preconditions
683:                   ADC1_Initialize() function should have been 
684:                   called before calling this function.
685:                
686:                 @Returns
687:                   None
688:               
689:                 @Param
690:                   Pass in required channel from the ADC1_CHANNEL list
691:                 
692:                 @Example
693:                   Refer to ADC1_Initialize(); for an example
694:                
695:               */
696:               
697:               inline static void ADC1_ChannelSelectSet( ADC1_CHANNEL channel )
698:               {
699:                   AD1CHS0bits.CH0SA = channel;
700:               }
701:               
702:               /**
703:                 @Summary
704:                   Returns the channel selected for conversion
705:               
706:                 @Description
707:                   This routine is used to return the channel selected for conversion.
708:                 
709:                 @Preconditions
710:                   ADC1_Initialize() function should have been 
711:                   called before calling this function.
712:                
713:                 @Returns
714:                   The value of the Channel Conversion register
715:               
716:                 @Param
717:                   None
718:                 
719:                 @Example
720:                   Refer to ADC1_Initialize(); for an example
721:                
722:               */
723:               
724:               inline static uint16_t ADC1_ChannelSelectGet( void )
725:               {
726:                   return AD1CHS0bits.CH0SA ;
727:               }
728:               
729:               /**
730:                 @Summary
731:                   Allows selection of a data format type for conversion
732:               
733:                 @Description
734:                   This routine is used to select desired data format for conversion.
735:                 
736:                 @Preconditions
737:                   ADC1_Initialize() function should have been 
738:                   called before calling this function.
739:                
740:                 @Returns
741:                   None
742:               
743:                 @Param
744:                   Pass in required data format type from the ADC1_FORM_TYPE list
745:                 
746:                 @Example
747:                   Refer to ADC1_Initialize(); for an example
748:               */
749:               
750:               inline static void ADC1_FormatDataSet( ADC1_FORM_TYPE form )
751:               {
752:                   AD1CON1bits.FORM = form;
753:               }
754:               
755:               /**
756:                 @Summary
757:                   Allows selection of a resolution mode for conversion
758:               
759:                 @Description
760:                   This routine is used to select desired resolution mode for conversion.
761:                 
762:                 @Preconditions
763:                   ADC1_Initialize() function should have been 
764:                   called before calling this function.
765:                
766:                 @Returns
767:                   None
768:               
769:                 @Param
770:                   Pass in required resolution mode from the ADC1_RESOLUTION_TYPE list
771:                 
772:                 @Example
773:                   Refer to ADC1_Initialize(); for an example
774:               */
775:               
776:               inline static void ADC1_ResolutionModeSet( ADC1_RESOLUTION_TYPE resolution )
777:               {
778:                   AD1CON1bits.AD12B = resolution;
779:               }
780:               
781:               /**
782:                 @Summary
783:                   Allows simultaneous sampling to be enabled manually
784:               
785:                 @Description
786:                   This routine is used to enable simultaneous sampling of channels manually
787:                 
788:                 @Preconditions
789:                   ADC1_Initialize() function should have been 
790:                   called before calling this function.
791:                
792:                 @Returns
793:                   None
794:               
795:                 @Param
796:                   None.
797:                 
798:                 @Example
799:                   Refer to ADC1_Initialize(); for an example
800:               
801:               */
802:               
803:               inline static void ADC1_SimultaneousSamplingEnable(void)
804:               {
805:                   AD1CON1bits.SIMSAM = 1;
806:               }
807:               
808:               /**
809:                 @Summary
810:                   Allows simultaneous sampling to be disabled manually
811:               
812:                 @Description
813:                   This routine is used to disable simultaneous sampling of channels manually
814:                 
815:                 @Preconditions
816:                   ADC1_Initialize() function should have been 
817:                   called before calling this function.
818:                
819:                 @Returns
820:                   None
821:               
822:                 @Param
823:                   None.
824:                 
825:                 @Example
826:                   Refer to ADC1_Initialize(); for an example
827:               */
828:               
829:               inline static void ADC1_SimultaneousSamplingDisble(void)
830:               {
831:                   AD1CON1bits.SIMSAM = 0;
832:               }
833:               
834:               /**
835:               @Summary
836:                   Allows sutomatic sampling to be enabled manually
837:               
838:                 @Description
839:                   This routine is used to enable automatic sampling of channels manually
840:                 
841:                 @Preconditions
842:                   ADC1_Initialize() function should have been 
843:                   called before calling this function.
844:                
845:                 @Returns
846:                   None
847:               
848:                 @Param
849:                   None.
850:                 
851:                 @Example
852:                   Refer to ADC1_Initialize(); for an example
853:               */
854:               
855:               inline static void ADC1_AutomaticSamplingEnable(void)
856:               {
857:                   AD1CON1bits.ASAM = 1;
858:               }
859:               
860:               /**
861:                 @Summary
862:                   Allows automatic sampling to be disabled manually
863:               
864:                 @Description
865:                   This routine is used to disable automatic sampling of channels manually
866:                 
867:                 @Preconditions
868:                   ADC1_Initialize() function should have been 
869:                   called before calling this function.
870:                
871:                 @Returns
872:                   None
873:               
874:                 @Param
875:                   None.
876:                 
877:                 @Example
878:                   Refer to ADC1_Initialize(); for an example
879:               */
880:               
881:               inline static void ADC1_AutomaticSamplingDisable(void)
882:               {
883:                   AD1CON1bits.ASAM = 0;
884:               }
885:               
886:               /**
887:                 @Summary
888:                   Allows conversion clock prescaler value to be set
889:               
890:                 @Description
891:                   This routine is used to allow conversion clock prescaler value to be set manually
892:                 
893:                 @Preconditions
894:                   ADC1_Initialize() function should have been 
895:                   called before calling this function.
896:                
897:                 @Returns
898:                   None
899:               
900:                 @Param
901:                   Pass in required prescaler integer value
902:                 
903:                 @Example
904:                   Refer to ADC1_Initialize(); for an example
905:                
906:               */
907:               
908:               inline static void ADC1_ConversionClockPrescalerSet(uint8_t prescaler)
909:               {
910:                   AD1CON3bits.ADCS = prescaler - 1;
911:               }
912:               
913:               /**
914:                 @Summary
915:                   Allows module to be enabled manually
916:               
917:                 @Description
918:                   This routine is used to enable the ADC1 module manually
919:                 
920:                 @Preconditions
921:                   ADC1_Initialize() function should have been 
922:                   called before calling this function.
923:                
924:                 @Returns
925:                   None
926:               
927:                 @Param
928:                   None
929:                 
930:                 @Example
931:               */
932:               
933:               inline static void ADC1_Enable(void)
934:               {
0004B0  FA0000     LNK #0x0
935:                   AD1CON1bits.ADON = 1;
0004B2  A8E321     BSET 0x321, #7
936:               }
0004B4  FA8000     ULNK
0004B6  060000     RETURN
937:               
938:               /**
939:                 @Summary
940:                   Allows module to be disabled manually
941:               
942:                 @Description
943:                   This routine is used to disable the ADC1 module manually
944:                 
945:                 @Preconditions
946:                   ADC1_Initialize() function should have been 
947:                   called before calling this function.
948:                
949:                 @Returns
950:                   None
951:               
952:                 @Param
953:                   None
954:                 
955:                 @Example
956:               */
957:               
958:               inline static void ADC1_Disable(void)
959:               {
960:                   AD1CON1bits.ADON = 0;
961:               }
962:               
963:               /**
964:                 @Summary
965:                   Allows selection of a positive 123 channel for conversion
966:               
967:                 @Description
968:                   This routine is used to select desired positive 123 channel for conversion.
969:                 
970:                 @Preconditions
971:                   ADC1_Initialize() function should have been 
972:                   called before calling this function.
973:                
974:                 @Returns
975:                   None
976:               
977:                 @Param
978:                   Pass in required channel from the ADC1_POS_123_CHANNEL list
979:                 
980:                 @Example
981:                   Refer to ADC1_Initialize(); for an example
982:                
983:               */
984:               
985:               inline static void ADC1_Positive123ChannelSelect( ADC1_POS_123_CHANNEL channel )
986:               {
987:                   AD1CHS123 = (AD1CHS123 & 0xFF06) | channel;
988:               }
989:               
990:               /**
991:                 @Summary
992:                   Allows selection of a negative 123 channel for conversion
993:               
994:                 @Description
995:                   This routine is used to select desired negative 123 channel for conversion.
996:                 
997:                 @Preconditions
998:                   ADC1_Initialize() function should have been 
999:                   called before calling this function.
1000:               
1001:                @Returns
1002:                  None
1003:              
1004:                @Param
1005:                  Pass in required channel from the ADC1_NEG_123_CHANNEL list
1006:                
1007:                @Example
1008:                  Refer to ADC1_Initialize(); for an example
1009:               
1010:              */
1011:              
1012:              inline static void ADC1_Negative123ChannelSelect( ADC1_NEG_123_CHANNEL channel )
1013:              {
1014:                  AD1CHS123bits.CH123NA = channel;
1015:              }
1016:              
1017:              /**
1018:                @Summary
1019:                  Allows selection of conversion channels
1020:              
1021:                @Description
1022:                  This routine is used to select conversion channel for conversion.
1023:                
1024:                @Preconditions
1025:                  ADC1_Initialize() function should have been 
1026:                  called before calling this function.
1027:               
1028:                @Returns
1029:                  None
1030:              
1031:                @Param
1032:                  Pass in required channel from the ADC1_CONVERSION_CHANNELS_TYPE list
1033:                
1034:                @Example
1035:                  Refer to ADC1_Initialize(); for an example
1036:               
1037:              */
1038:              
1039:              inline static void ADC1_ConversionChannelsSet( ADC1_CONVERSION_CHANNELS_TYPE channel )
1040:              {
1041:                  AD1CON2bits.CHPS = channel;
1042:              }
1043:              
1044:              /**
1045:                @Summary
1046:                  Allows selection of a priority for interrupt
1047:              
1048:                @Description
1049:                  This routine is used to select desired priority for interrupt.
1050:                
1051:                @Preconditions
1052:                  ADC1_Initialize() function should have been 
1053:                  called before calling this function.
1054:               
1055:                @Returns
1056:                  None
1057:              
1058:                @Param
1059:                  Pass in required integer priority value
1060:                
1061:                @Example
1062:                  Refer to ADC1_Initialize(); for an example
1063:               
1064:              */
1065:              
1066:              inline static void ADC1_InterruptPrioritySet( uint16_t priorityValue )
1067:              {
1068:                  _AD1IP = 0x7 & priorityValue;
1069:              }
1070:              
1071:              /**
1072:                @Summary
1073:                  Callback for ADC1.
1074:              
1075:                @Description
1076:                  This routine is callback for ADC1
1077:              
1078:                @Param
1079:                  None.
1080:              
1081:                @Returns
1082:                  None
1083:               
1084:                @Example 
1085:              	Refer to ADC1_Initialize(); for an example
1086:              */
1087:              void ADC1_CallBack(void);
1088:              
1089:                      
1090:              #ifdef __cplusplus  // Provide C++ Compatibility
1091:              
1092:                  }
1093:              
1094:              #endif
1095:              
1096:              #endif //_ADC1_H
1097:                  
1098:              /**
1099:               End of File
1100:              */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/mcc_generated_files/adc1.c  --------
1:                 
2:                 /**
3:                   ADC1 Generated Driver File
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     adc1.c
10:                
11:                  @Summary
12:                    This is the generated header file for the ADC1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This header file provides APIs for driver for ADC1.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB 	          :  MPLAB X v5.20
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include "adc1.h"
51:                
52:                bool data_ready = 0;
53:                uint16_t adc_buffer[ADC_BUF_SIZE] = { 0 };
54:                
55:                
56:                /**
57:                  Section: Data Type Definitions
58:                */
59:                
60:                /* ADC Driver Hardware Instance Object
61:                
62:                  @Summary
63:                    Defines the object required for the maintenance of the hardware instance.
64:                
65:                  @Description
66:                    This defines the object required for the maintenance of the hardware
67:                    instance. This object exists once per hardware instance of the peripheral.
68:                
69:                 */
70:                typedef struct
71:                {
72:                	uint8_t intSample;
73:                }
74:                
75:                ADC_OBJECT;
76:                
77:                static ADC_OBJECT adc1_obj;
78:                
79:                /**
80:                  Section: Driver Interface
81:                */
82:                
83:                
84:                void ADC1_Initialize (void)
85:                {
000620  FA0000     LNK #0x0
86:                    // ASAM enabled; ADDMABM disabled; ADSIDL disabled; DONE disabled; SIMSAM Simultaneous; FORM Absolute decimal result, unsigned, right-justified; SAMP disabled; SSRC TMR3; AD12B 10-bit; ADON enabled; SSRCG disabled; 
87:                
88:                   AD1CON1 = 0b1000000001001100;
000622  2804C0     MOV #0x804C, W0
000624  881900     MOV W0, AD1CON1
89:                
90:                    // CSCNA disabled; VCFG0 AVDD; VCFG1 AVSS; ALTS disabled; BUFM disabled; SMPI Generates interrupt after completion of every sample/conversion operation; CHPS 2 Channel; 
91:                
92:                   AD1CON2 = 0b000000100000000;
000626  201000     MOV #0x100, W0
000628  881910     MOV W0, AD1CON2
93:                
94:                    // SAMC 5; ADRC FOSC/2; ADCS 0; 
95:                
96:                   AD1CON3 = 0x500;
00062A  205000     MOV #0x500, W0
00062C  881920     MOV W0, AD1CON3
97:                
98:                    // CH0SA AN2; CH0SB AN2; CH0NB VREFL; CH0NA VREFL; 
99:                
100:                  AD1CHS0 = 0b0000001000000010;
00062E  202020     MOV #0x202, W0
000630  881940     MOV W0, AD1CHS0
101:               
102:                   // CSS26 disabled; CSS25 disabled; CSS24 disabled; CSS27 disabled; 
103:               
104:                  AD1CSSH = 0x00;
000632  EF232E     CLR AD1CSSH
105:               
106:                   // CSS2 disabled; CSS1 disabled; CSS0 disabled; CSS5 disabled; CSS4 disabled; CSS3 disabled; 
107:               
108:                  AD1CSSL = 0x00;
000634  EF2330     CLR AD1CSSL
109:               
110:                   // DMABL Allocates 1 word of buffer to each analog input; ADDMAEN disabled; 
111:               
112:                  AD1CON4 = 0x00;
000636  EF2332     CLR AD1CON4
113:               
114:                   // CH123SA2 CH1=OA1/AN3; CH123SB2 CH1=OA1/AN3; CH123NA CH1=VREF-; CH123NB CH1=VREF-; 
115:               
116:                  AD1CHS123 = 0x101;
000638  201010     MOV #0x101, W0
00063A  881930     MOV W0, AD1CHS123
117:               
118:                  
119:                  adc1_obj.intSample = AD1CON2bits.SMPI;
00063C  801910     MOV AD1CON2, W0
00063E  DE0042     LSR W0, #2, W0
000640  60407F     AND.B W0, #0x1F, W0
000642  B7F04A     MOV.B WREG, adc1_obj
120:                  
121:                  data_ready = 0;
000644  EF7028     CLR.B data_ready
122:                          
123:                  // Enabling ADC1 interrupt.
124:                  IEC0bits.AD1IE = 1;
000646  A8A821     BSET 0x821, #5
125:               
126:               }
000648  FA8000     ULNK
00064A  060000     RETURN
127:               
128:               void __attribute__ ((weak)) ADC1_CallBack(void)
129:               {
00064C  FA0000     LNK #0x0
130:                   // Add your custom callback code here
131:               }
00064E  FA8000     ULNK
000650  060000     RETURN
132:               
133:               void __attribute__ ( ( __interrupt__ , auto_psv ) ) _AD1Interrupt ( void )
134:               {
000334  781F80     MOV W0, [W15++]
000336  F80032     PUSH DSRPAG
000338  F80034     PUSH DSWPAG
00033A  200010     MOV #0x1, W0
00033C  8801A0     MOV W0, DSWPAG
00033E  200010     MOV #0x1, W0
000340  880190     MOV W0, DSRPAG
000342  000000     NOP
000344  FA0000     LNK #0x0
135:               	// ADC1 callback function 
136:               	//ADC1_CallBack();
137:               	
138:                   adc_buffer[0] = ADC1BUF0;
000346  801800     MOV ADC1BUF0, W0
000348  888150     MOV W0, adc_buffer
139:                   adc_buffer[1] = ADC1BUF1;
00034A  801810     MOV ADC1BUF1, W0
00034C  888160     MOV W0, 0x102C
140:                   adc_buffer[2] = ADC1BUF2;
00034E  801820     MOV ADC1BUF2, W0
000350  888170     MOV W0, 0x102E
141:                   adc_buffer[3] = ADC1BUF3;
000352  801830     MOV ADC1BUF3, W0
000354  888180     MOV W0, 0x1030
142:                   adc_buffer[4] = ADC1BUF4;
000356  801840     MOV ADC1BUF4, W0
000358  888190     MOV W0, 0x1032
143:                   adc_buffer[5] = ADC1BUF5;
00035A  801850     MOV ADC1BUF5, W0
00035C  8881A0     MOV W0, 0x1034
144:                   adc_buffer[6] = ADC1BUF6;
00035E  801860     MOV ADC1BUF6, W0
000360  8881B0     MOV W0, 0x1036
145:                   adc_buffer[7] = ADC1BUF7;
000362  801870     MOV ADC1BUF7, W0
000364  8881C0     MOV W0, 0x1038
146:                   adc_buffer[8] = ADC1BUF8;
000366  801880     MOV ADC1BUF8, W0
000368  8881D0     MOV W0, 0x103A
147:                   adc_buffer[9] = ADC1BUF9;
00036A  801890     MOV ADC1BUF9, W0
00036C  8881E0     MOV W0, 0x103C
148:                   adc_buffer[10] = ADC1BUFA;
00036E  8018A0     MOV ADC1BUFA, W0
000370  8881F0     MOV W0, 0x103E
149:                   adc_buffer[11] = ADC1BUFB;
000372  8018B0     MOV ADC1BUFB, W0
000374  888200     MOV W0, 0x1040
150:                   adc_buffer[12] = ADC1BUFC;
000376  8018C0     MOV ADC1BUFC, W0
000378  888210     MOV W0, 0x1042
151:                   adc_buffer[13] = ADC1BUFD;
00037A  8018D0     MOV ADC1BUFD, W0
00037C  888220     MOV W0, 0x1044
152:                   adc_buffer[14] = ADC1BUFE;
00037E  8018E0     MOV ADC1BUFE, W0
000380  888230     MOV W0, 0x1046
153:                   adc_buffer[15] = ADC1BUFF;
000382  8018F0     MOV ADC1BUFF, W0
000384  888240     MOV W0, 0x1048
154:                   
155:                   
156:                   data_ready = true;
000386  B3C010     MOV.B #0x1, W0
000388  B7F028     MOV.B WREG, data_ready
157:                   
158:                   // clear the ADC interrupt flag
159:                   IFS0bits.AD1IF = false;
00038A  A9A801     BCLR 0x801, #5
160:               }
00038C  FA8000     ULNK
00038E  F90034     POP DSWPAG
000390  F90032     POP DSRPAG
000392  78004F     MOV [--W15], W0
000394  064000     RETFIE
161:               
162:               uint16_t* ADC1_Get_Buffer_Ptr(void) {
000652  FA0000     LNK #0x0
163:                   return &adc_buffer;
000654  2102A0     MOV #0x102A, W0
164:               }
000656  FA8000     ULNK
000658  060000     RETURN
165:               
166:               bool ADC1_Is_Data_Ready(void) {
00065A  FA0000     LNK #0x0
167:                   return data_ready;
00065C  BFD028     MOV.B data_ready, WREG
168:               }
00065E  FA8000     ULNK
000660  060000     RETURN
169:               
170:               void ADC1_Acknowledge_Data_Ready(void) {
000662  FA0000     LNK #0x0
171:                   data_ready = false;
000664  EF7028     CLR.B data_ready
172:               }
000666  FA8000     ULNK
000668  060000     RETURN
173:               
174:               /**
175:                 End of File
176:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSensorModule.X/main.c  ----------------------------
1:                 /**
2:                   Generated main.c file from MPLAB Code Configurator
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     main.c
9:                 
10:                  @Summary
11:                    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.
12:                
13:                  @Description
14:                    This source file provides main entry point for system initialization and application code development.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB 	          :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include "mcc_generated_files/system.h"
49:                #include "mcc_generated_files/adc1.h"
50:                
51:                uint16_t process_current(uint16_t);
52:                uint16_t process_voltage(uint16_t);
53:                uint16_t calibrate_current(uint16_t);
54:                uint16_t calibrate_voltage(uint16_t);
55:                void CAN_send(uint16_t);
56:                
57:                
58:                uint16_t current_calibration[10];
59:                uint16_t voltage_calibration[10];
60:                
61:                /*
62:                                         Main application
63:                 */
64:                int main(void)
65:                {
0004B8  FA002A     LNK #0x2A
66:                    uint16_t current_readings[ADC_BUF_SIZE / 2];
67:                    uint16_t voltage_readings[ADC_BUF_SIZE / 2];
68:                    
69:                    uint16_t current_avg;
70:                    uint16_t voltage_avg;
71:                    
72:                    // initialize the device
73:                    SYSTEM_Initialize();
0004BA  070104     RCALL SYSTEM_Initialize
74:                    ADC1_Enable();
0004BC  07FFF9     RCALL .Letext0, .LFE9, _ADC1_Enable, .Ltext0, .LFB24
0004BE  370001     BRA .L8
75:                    
76:                    while (1)
77:                    {
78:                        if (ADC1_Is_Data_Ready() == true) {
0004C2  0700CB     RCALL ADC1_Is_Data_Ready
0004C4  E00400     CP0.B W0
0004C6  32FFFC     BRA Z, .L9
79:                            ADC1_Acknowledge_Data_Ready();  
0004C8  0700CC     RCALL ADC1_Acknowledge_Data_Ready
80:                            
81:                            uint16_t *data = ADC1_Get_Buffer_Ptr(); 
0004CA  0700C3     RCALL ADC1_Get_Buffer_Ptr
0004CC  980730     MOV W0, [W14+6]
82:                            
83:                            // process sampled data
84:                            uint16_t buffer_index = 0;
0004CE  EB0000     CLR W0
0004D0  980740     MOV W0, [W14+8]
85:                            uint16_t i;
86:                            for (i = 0; i < ADC_BUF_SIZE / 2; i++) {
0004D2  EB0000     CLR W0
0004D4  980720     MOV W0, [W14+4]
0004D6  37001D     BRA .L4
00050C  90002E     MOV [W14+4], W0
00050E  E80000     INC W0, W0
000510  980720     MOV W0, [W14+4]
000512  90002E     MOV [W14+4], W0
000514  500FE7     SUB W0, #0x7, [W15]
000516  36FFE0     BRA LEU, .L5
87:                                buffer_index = i * 2;
0004D8  90002E     MOV [W14+4], W0
0004DA  400000     ADD W0, W0, W0
0004DC  980740     MOV W0, [W14+8]
88:                                current_readings[i] = process_current(data[buffer_index]);    
0004DE  90004E     MOV [W14+8], W0
0004E0  400000     ADD W0, W0, W0
0004E2  9000BE     MOV [W14+6], W1
0004E4  408000     ADD W1, W0, W0
0004E6  780010     MOV [W0], W0
0004E8  070037     RCALL process_current
0004EA  780080     MOV W0, W1
0004EC  90002E     MOV [W14+4], W0
0004EE  400000     ADD W0, W0, W0
0004F0  40006A     ADD W0, #0xA, W0
0004F2  783701     MOV W1, [W14+W0]
89:                                voltage_readings[i] = process_voltage(data[buffer_index + 1]);  
0004F4  90004E     MOV [W14+8], W0
0004F6  E80000     INC W0, W0
0004F8  400000     ADD W0, W0, W0
0004FA  9000BE     MOV [W14+6], W1
0004FC  408000     ADD W1, W0, W0
0004FE  780010     MOV [W0], W0
000500  070036     RCALL process_voltage
000502  780080     MOV W0, W1
000504  90002E     MOV [W14+4], W0
000506  400000     ADD W0, W0, W0
000508  40007A     ADD W0, #0x1A, W0
00050A  783701     MOV W1, [W14+W0]
90:                            }
91:                            
92:                            // average data
93:                            for (i = 0; i < ADC_BUF_SIZE / 2; i++) {
000518  EB0000     CLR W0
00051A  980720     MOV W0, [W14+4]
00051C  37000F     BRA .L6
000536  90002E     MOV [W14+4], W0
000538  E80000     INC W0, W0
00053A  980720     MOV W0, [W14+4]
00053C  90002E     MOV [W14+4], W0
00053E  500FE7     SUB W0, #0x7, [W15]
000540  36FFEE     BRA LEU, .L7
94:                                current_avg += current_readings[i];
00051E  90002E     MOV [W14+4], W0
000520  400000     ADD W0, W0, W0
000522  40006A     ADD W0, #0xA, W0
000524  78006E     MOV [W14+W0], W0
000526  400F1E     ADD W0, [W14], [W14]
95:                                voltage_avg += voltage_readings[i];
000528  90002E     MOV [W14+4], W0
00052A  400000     ADD W0, W0, W0
00052C  40007A     ADD W0, #0x1A, W0
00052E  78006E     MOV [W14+W0], W0
000530  90009E     MOV [W14+2], W1
000532  408000     ADD W1, W0, W0
000534  980710     MOV W0, [W14+2]
96:                            }
97:                            current_avg /= ADC_BUF_SIZE / 2;
000542  78001E     MOV [W14], W0
000544  DE0043     LSR W0, #3, W0
000546  780F00     MOV W0, [W14]
98:                            voltage_avg /= ADC_BUF_SIZE / 2;
000548  90001E     MOV [W14+2], W0
00054A  DE0043     LSR W0, #3, W0
00054C  980710     MOV W0, [W14+2]
99:                                
100:                           // send data over CAN
101:                           CAN_send(current_avg);
00054E  78001E     MOV [W14], W0
000550  070019     RCALL CAN_send
102:                           CAN_send(voltage_avg);
000552  90001E     MOV [W14+2], W0
000554  070017     RCALL CAN_send
103:                       }
104:                   }
0004C0  000000     NOP
000556  37FFB5     BRA .L8
105:                   return 1; 
106:               }
107:               
108:               uint16_t process_current(uint16_t data) {
000558  FA0002     LNK #0x2
00055A  780F00     MOV W0, [W14]
109:                   // STUFF
110:                    return calibrate_current(data);
00055C  78001E     MOV [W14], W0
00055E  070002     RCALL calibrate_current
111:               }
000560  FA8000     ULNK
000562  060000     RETURN
112:               
113:               uint16_t calibrate_current(uint16_t data) {
000564  FA0002     LNK #0x2
000566  780F00     MOV W0, [W14]
114:                   // STUFF
115:                   return data;
000568  78001E     MOV [W14], W0
116:               }
00056A  FA8000     ULNK
00056C  060000     RETURN
117:               
118:               uint16_t process_voltage(uint16_t data) {
00056E  FA0002     LNK #0x2
000570  780F00     MOV W0, [W14]
119:                   // STUFF
120:                    return calibrate_voltage(data);
000572  78001E     MOV [W14], W0
000574  070002     RCALL calibrate_voltage
121:               }
000576  FA8000     ULNK
000578  060000     RETURN
122:               
123:               uint16_t calibrate_voltage(uint16_t data) {
00057A  FA0002     LNK #0x2
00057C  780F00     MOV W0, [W14]
124:                   // STUFF
125:                   return data;
00057E  78001E     MOV [W14], W0
126:               }
000580  FA8000     ULNK
000582  060000     RETURN
127:               
128:               void CAN_send(uint16_t data) {
000584  FA0002     LNK #0x2
000586  780F00     MOV W0, [W14]
129:                   return;
130:               }
000588  FA8000     ULNK
00058A  060000     RETURN
131:               
132:               /**
133:                End of File
134:               */
135:               
