Disassembly Listing for PowerSenseModule
Generated From:
C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/dist/default/debug/PowerSenseModule.X.debug.elf
Aug 11, 2019 12:50:42 AM

---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/traps.c  --------
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
52:                #define ERROR_HANDLER_NORETURN ERROR_HANDLER __attribute__((noreturn))
53:                #define FAILSAFE_STACK_GUARDSIZE 8
54:                
55:                /**
56:                 * a private place to store the error code if we run into a severe error
57:                 */
58:                static uint16_t TRAPS_error_code = -1;
59:                
60:                /**
61:                 * Halts 
62:                 * 
63:                 * @param code error code
64:                 */
65:                void __attribute__((naked, noreturn, weak)) TRAPS_halt_on_error(uint16_t code)
66:                {
000B2A  780F00     MOV W0, [W14]
67:                    TRAPS_error_code = code;
000B2C  78009E     MOV [W14], W1
000B2E  888761     MOV W1, 0x10EC
000B30  DA4000     BREAK
68:                #ifdef __DEBUG    
69:                    __builtin_software_breakpoint();
70:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
71:                #endif
72:                    while(1);
000B32  37FFFF     BRA .L2
73:                    
74:                }
75:                
76:                /**
77:                 * Sets the stack pointer to a backup area of memory, in case we run into
78:                 * a stack error (in which case we can't really trust the stack pointer)
79:                 */
80:                inline static void use_failsafe_stack(void)
81:                {
000B34  FA0000     LNK #0x0
82:                    static uint8_t failsafe_stack[32];
83:                    asm volatile (
000B36  210C40     MOV #0x10C4, W0
000B38  780780     MOV W0, W15
84:                        "   mov    %[pstack], W15\n"
85:                        :
86:                        : [pstack]"r"(failsafe_stack)
87:                    );
88:                /* Controls where the stack pointer limit is, relative to the end of the
89:                 * failsafe stack
90:                 */    
91:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
000B3A  210DC0     MOV #0x10DC, W0
000B3C  880100     MOV W0, SPLIM
92:                            - FAILSAFE_STACK_GUARDSIZE);
93:                }
000B3E  FA8000     ULNK
000B40  060000     RETURN
94:                
95:                
96:                /** Oscillator Fail Trap vector**/
97:                void ERROR_HANDLER_NORETURN _OscillatorFail(void)
98:                {
000302  F80036     PUSH RCOUNT
99:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
000304  A928C0     BCLR INTCON1, #1
100:                   TRAPS_halt_on_error(TRAPS_OSC_FAIL);
000306  EB0000     CLR W0
000308  070410     RCALL TRAPS_halt_on_error
101:               }
102:               /** Stack Error Trap Vector**/
103:               void ERROR_HANDLER_NORETURN _StackError(void)
104:               {
00030A  F80036     PUSH RCOUNT
105:                   /* We use a failsafe stack: the presence of a stack-pointer error
106:                    * means that we cannot trust the stack to operate correctly unless
107:                    * we set the stack pointer to a safe place.
108:                    */
109:                   use_failsafe_stack(); 
00030C  070413     RCALL _use_failsafe_stack, .LFE0, .LFB1
110:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
00030E  A948C0     BCLR INTCON1, #2
111:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
000310  200010     MOV #0x1, W0
000312  07040B     RCALL TRAPS_halt_on_error
112:               }
113:               /** Address error Trap vector**/
114:               void ERROR_HANDLER_NORETURN _AddressError(void)
115:               {
000314  F80036     PUSH RCOUNT
116:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
000316  A968C0     BCLR INTCON1, #3
117:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
000318  200020     MOV #0x2, W0
00031A  070407     RCALL TRAPS_halt_on_error
118:               }
119:               /** Math Error Trap vector**/
120:               void ERROR_HANDLER_NORETURN _MathError(void)
121:               {
00031C  F80036     PUSH RCOUNT
122:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
00031E  A988C0     BCLR INTCON1, #4
123:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
000320  200030     MOV #0x3, W0
000322  070403     RCALL TRAPS_halt_on_error
124:               }
125:               /** DMAC Error Trap vector**/
126:               void ERROR_HANDLER_NORETURN _DMACError(void)
127:               {
000324  F80036     PUSH RCOUNT
128:                   INTCON1bits.DMACERR = 0;  //Clear the trap flag
000326  A9A8C0     BCLR INTCON1, #5
129:                   TRAPS_halt_on_error(TRAPS_DMAC_ERR);
000328  200040     MOV #0x4, W0
00032A  0703FF     RCALL TRAPS_halt_on_error
130:               }
131:               /** Generic Hard Trap vector**/
132:               void ERROR_HANDLER_NORETURN _HardTrapError(void)
133:               {
00032C  F80036     PUSH RCOUNT
134:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
00032E  A908C6     BCLR INTCON4, #0
135:                   TRAPS_halt_on_error(TRAPS_HARD_ERR);
000330  200070     MOV #0x7, W0
000332  0703FB     RCALL TRAPS_halt_on_error
136:               }
137:               /** Generic Soft Trap vector**/
138:               void ERROR_HANDLER_NORETURN _SoftTrapError(void)
139:               {
000334  F80036     PUSH RCOUNT
140:                   INTCON3bits.DOOVR = 0;  //Clear the trap flag
000336  A988C4     BCLR INTCON3, #4
141:                   TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
000338  2000A0     MOV #0xA, W0
00033A  0703F7     RCALL TRAPS_halt_on_error
142:               }
143:               
144:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/tmr3.c  ---------
1:                 
2:                 /**
3:                   TMR3 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr3.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR3 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR3. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <stdio.h>
51:                #include "tmr3.h"
52:                #include "clock.h"
53:                #include "adc1.h"   
54:                
55:                /**
56:                 Section: File specific functions
57:                */
58:                
59:                /**
60:                  Section: Data Type Definitions
61:                */
62:                
63:                /** TMR Driver Hardware Instance Object
64:                
65:                  @Summary
66:                    Defines the object required for the maintenance of the hardware instance.
67:                
68:                  @Description
69:                    This defines the object required for the maintenance of the hardware
70:                    instance. This object exists once per hardware instance of the peripheral.
71:                
72:                  Remarks:
73:                    None.
74:                */
75:                
76:                typedef struct _TMR_OBJ_STRUCT
77:                {
78:                    /* Timer Elapsed */
79:                    volatile bool           timerElapsed;
80:                    /*Software Counter value*/
81:                    volatile uint8_t        count;
82:                
83:                } TMR_OBJ;
84:                
85:                static TMR_OBJ tmr3_obj;
86:                
87:                /**
88:                  Section: Driver Interface
89:                */
90:                
91:                void TMR3_Initialize (void)
92:                {
00095C  FA0000     LNK #0x0
93:                    //TMR3 0; 
94:                    TMR3 = 0x00;
00095E  EF210A     CLR TMR3
95:                  
96:                    PR3 = ADC_CONV_TIME_TAD + ADC1CLOCK_MultiplierGet() + 2;
000960  07FF9D     RCALL ADC1CLOCK_MultiplierGet
000962  40006E     ADD W0, #0xE, W0
000964  880870     MOV W0, PR3
97:                    //TCKPS 1:1; TON disabled; TSIDL disabled; TCS FOSC/2; TGATE disabled; 
98:                    T3CON = 0x0000;
000966  EF2112     CLR T3CON
99:                
100:               	
101:                   tmr3_obj.timerElapsed = false;
000968  EF70EE     CLR.B tmr3_obj
102:               
103:               }
00096A  FA8000     ULNK
00096C  060000     RETURN
104:               
105:               
106:               void TMR3_Tasks_16BitOperation( void )
107:               {
00096E  FA0000     LNK #0x0
108:                   /* Check if the Timer Interrupt/Status is set */
109:                   if(IFS0bits.T3IF)
000970  804001     MOV IFS0, W1
000972  201000     MOV #0x100, W0
000974  608000     AND W1, W0, W0
000976  E00000     CP0 W0
000978  320006     BRA Z, .L2
110:                   {
111:                       tmr3_obj.count++;
00097A  BFD0EF     MOV.B 0x10EF, WREG
00097C  E84000     INC.B W0, W0
00097E  B7F0EF     MOV.B WREG, 0x10EF
112:                       tmr3_obj.timerElapsed = true;
000980  B3C010     MOV.B #0x1, W0
000982  B7F0EE     MOV.B WREG, tmr3_obj
113:                       IFS0bits.T3IF = false;
000984  A90801     BCLR 0x801, #0
114:                   }
115:               }
000986  FA8000     ULNK
000988  060000     RETURN
116:               
117:               void TMR3_Period16BitSet( uint16_t value )
118:               {
00098A  FA0002     LNK #0x2
00098C  780F00     MOV W0, [W14]
119:                   /* Update the counter values */
120:                   PR3 = value;
00098E  78009E     MOV [W14], W1
000990  880871     MOV W1, PR3
121:                   /* Reset the status information */
122:                   tmr3_obj.timerElapsed = false;
000992  EF70EE     CLR.B tmr3_obj
123:               }
000994  FA8000     ULNK
000996  060000     RETURN
124:               
125:               uint16_t TMR3_Period16BitGet( void )
126:               {
000998  FA0000     LNK #0x0
127:                   return( PR3 );
00099A  800870     MOV PR3, W0
128:               }
00099C  FA8000     ULNK
00099E  060000     RETURN
129:               
130:               void TMR3_Counter16BitSet ( uint16_t value )
131:               {
0009A0  FA0002     LNK #0x2
0009A2  780F00     MOV W0, [W14]
132:                   /* Update the counter values */
133:                   TMR3 = value;
0009A4  78009E     MOV [W14], W1
0009A6  880851     MOV W1, TMR3
134:                   /* Reset the status information */
135:                   tmr3_obj.timerElapsed = false;
0009A8  EF70EE     CLR.B tmr3_obj
136:               }
0009AA  FA8000     ULNK
0009AC  060000     RETURN
137:               
138:               uint16_t TMR3_Counter16BitGet( void )
139:               {
0009AE  FA0000     LNK #0x0
140:                   return( TMR3 );
0009B0  800850     MOV TMR3, W0
141:               }
0009B2  FA8000     ULNK
0009B4  060000     RETURN
142:               
143:               
144:               
145:               
146:               void TMR3_Start( void )
147:               {
0009B6  FA0000     LNK #0x0
148:                   /* Reset the status information */
149:                   tmr3_obj.timerElapsed = false;
0009B8  EF70EE     CLR.B tmr3_obj
150:               
151:               
152:                   /* Start the Timer */
153:                   T3CONbits.TON = 1;
0009BA  A8E113     BSET 0x113, #7
154:               }
0009BC  FA8000     ULNK
0009BE  060000     RETURN
155:               
156:               void TMR3_Stop( void )
157:               {
0009C0  FA0000     LNK #0x0
158:                   /* Stop the Timer */
159:                   T3CONbits.TON = false;
0009C2  A9E113     BCLR 0x113, #7
160:               
161:               }
0009C4  FA8000     ULNK
0009C6  060000     RETURN
162:               
163:               bool TMR3_GetElapsedThenClear(void)
164:               {
0009C8  FA0002     LNK #0x2
165:                   bool status;
166:                   
167:                   status = tmr3_obj.timerElapsed;
0009CA  210EE1     MOV #0x10EE, W1
0009CC  784091     MOV.B [W1], W1
0009CE  784F01     MOV.B W1, [W14]
168:               
169:                   if(status == true)
0009D0  78401E     MOV.B [W14], W0
0009D2  E00400     CP0.B W0
0009D4  320001     BRA Z, .L11
170:                   {
171:                       tmr3_obj.timerElapsed = false;
0009D6  EF70EE     CLR.B tmr3_obj
172:                   }
173:                   return status;
0009D8  78401E     MOV.B [W14], W0
174:               }
0009DA  FA8000     ULNK
0009DC  060000     RETURN
175:               
176:               int TMR3_SoftwareCounterGet(void)
177:               {
0009DE  FA0000     LNK #0x0
178:                   return tmr3_obj.count;
0009E0  BFD0EF     MOV.B 0x10EF, WREG
0009E2  FB8000     ZE W0, W0
179:               }
0009E4  FA8000     ULNK
0009E6  060000     RETURN
180:               
181:               void TMR3_SoftwareCounterClear(void)
182:               {
0009E8  FA0000     LNK #0x0
183:                   tmr3_obj.count = 0; 
0009EA  EF70EF     CLR.B 0x10EF
184:               }
0009EC  FA8000     ULNK
0009EE  060000     RETURN
185:               
186:               /**
187:                End of File
188:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/tmr1.c  ---------
1:                 
2:                 /**
3:                   TMR1 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr1.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR1. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <stdio.h>
51:                #include "tmr1.h"
52:                
53:                /**
54:                 Section: File specific functions
55:                */
56:                void (*TMR1_InterruptHandler)(void) = NULL;
57:                void TMR1_CallBack(void);
58:                
59:                /**
60:                  Section: Data Type Definitions
61:                */
62:                
63:                /** TMR Driver Hardware Instance Object
64:                
65:                  @Summary
66:                    Defines the object required for the maintenance of the hardware instance.
67:                
68:                  @Description
69:                    This defines the object required for the maintenance of the hardware
70:                    instance. This object exists once per hardware instance of the peripheral.
71:                
72:                  Remarks:
73:                    None.
74:                */
75:                
76:                typedef struct _TMR_OBJ_STRUCT
77:                {
78:                    /* Timer Elapsed */
79:                    volatile bool           timerElapsed;
80:                    /*Software Counter value*/
81:                    volatile uint8_t        count;
82:                
83:                } TMR_OBJ;
84:                
85:                static TMR_OBJ tmr1_obj;
86:                
87:                /**
88:                  Section: Driver Interface
89:                */
90:                
91:                void TMR1_Initialize (void)
92:                {
0008BC  FA0000     LNK #0x0
93:                    //TMR1 0; 
94:                    TMR1 = 0x00;
0008BE  EF2100     CLR TMR1
95:                    //Period = 0.002 s; Frequency = 3685000 Hz; PR1 7369; 
96:                    PR1 = 0x1CC9;
0008C0  21CC90     MOV #0x1CC9, W0
0008C2  880810     MOV W0, PR1
97:                    //TCKPS 1:1; TON enabled; TSIDL disabled; TCS FOSC/2; TSYNC disabled; TGATE disabled; 
98:                    T1CON = 0x8000;
0008C4  280000     MOV #0x8000, W0
0008C6  880820     MOV W0, T1CON
99:                
100:                   if(TMR1_InterruptHandler == NULL)
0008C8  808740     MOV TMR1_InterruptHandler, W0
0008CA  E00000     CP0 W0
0008CC  3A0002     BRA NZ, .L2
101:                   {
102:                       TMR1_SetInterruptHandler(&TMR1_CallBack);
0008CE  209080     MOV #0x908, W0
0008D0  07001E     RCALL TMR1_SetInterruptHandler
103:                   }
104:               
105:                   IFS0bits.T1IF = false;
0008D2  A96800     BCLR IFS0, #3
106:                   IEC0bits.T1IE = true;
0008D4  A86820     BSET IEC0, #3
107:               	
108:                   tmr1_obj.timerElapsed = false;
0008D6  EF70EA     CLR.B tmr1_obj
109:               
110:               }
0008D8  FA8000     ULNK
0008DA  060000     RETURN
111:               
112:               
113:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T1Interrupt (  )
114:               {
00033C  F80036     PUSH RCOUNT
00033E  BE9F80     MOV.D W0, [W15++]
000340  BE9F82     MOV.D W2, [W15++]
000342  BE9F84     MOV.D W4, [W15++]
000344  BE9F86     MOV.D W6, [W15++]
000346  FA0000     LNK #0x0
115:                   /* Check if the Timer Interrupt/Status is set */
116:               
117:                   //***User Area Begin
118:               
119:                   // ticker function call;
120:                   // ticker is 1 -> Callback function gets called everytime this ISR executes
121:                   if(TMR1_InterruptHandler) 
000348  808740     MOV TMR1_InterruptHandler, W0
00034A  E00000     CP0 W0
00034C  320002     BRA Z, .L4
122:                   { 
123:                          TMR1_InterruptHandler(); 
00034E  808740     MOV TMR1_InterruptHandler, W0
000350  010000     CALL W0
124:                   }
125:               
126:                   //***User Area End
127:               
128:                   tmr1_obj.count++;
000352  BFD0EB     MOV.B 0x10EB, WREG
000354  E84000     INC.B W0, W0
000356  B7F0EB     MOV.B WREG, 0x10EB
129:                   tmr1_obj.timerElapsed = true;
000358  B3C010     MOV.B #0x1, W0
00035A  B7F0EA     MOV.B WREG, tmr1_obj
130:                   IFS0bits.T1IF = false;
00035C  A96800     BCLR IFS0, #3
131:               }
00035E  FA8000     ULNK
000360  BE034F     MOV.D [--W15], W6
000362  BE024F     MOV.D [--W15], W4
000364  BE014F     MOV.D [--W15], W2
000366  BE004F     MOV.D [--W15], W0
000368  F90036     POP RCOUNT
00036A  064000     RETFIE
132:               
133:               void TMR1_Period16BitSet( uint16_t value )
134:               {
0008DC  FA0002     LNK #0x2
0008DE  780F00     MOV W0, [W14]
135:                   /* Update the counter values */
136:                   PR1 = value;
0008E0  78009E     MOV [W14], W1
0008E2  880811     MOV W1, PR1
137:                   /* Reset the status information */
138:                   tmr1_obj.timerElapsed = false;
0008E4  EF70EA     CLR.B tmr1_obj
139:               }
0008E6  FA8000     ULNK
0008E8  060000     RETURN
140:               
141:               uint16_t TMR1_Period16BitGet( void )
142:               {
0008EA  FA0000     LNK #0x0
143:                   return( PR1 );
0008EC  800810     MOV PR1, W0
144:               }
0008EE  FA8000     ULNK
0008F0  060000     RETURN
145:               
146:               void TMR1_Counter16BitSet ( uint16_t value )
147:               {
0008F2  FA0002     LNK #0x2
0008F4  780F00     MOV W0, [W14]
148:                   /* Update the counter values */
149:                   TMR1 = value;
0008F6  78009E     MOV [W14], W1
0008F8  880801     MOV W1, TMR1
150:                   /* Reset the status information */
151:                   tmr1_obj.timerElapsed = false;
0008FA  EF70EA     CLR.B tmr1_obj
152:               }
0008FC  FA8000     ULNK
0008FE  060000     RETURN
153:               
154:               uint16_t TMR1_Counter16BitGet( void )
155:               {
000900  FA0000     LNK #0x0
156:                   return( TMR1 );
000902  800800     MOV TMR1, W0
157:               }
000904  FA8000     ULNK
000906  060000     RETURN
158:               
159:               
160:               void __attribute__ ((weak)) TMR1_CallBack(void)
161:               {
000908  FA0000     LNK #0x0
162:                   // Add your custom callback code here
163:               }
00090A  FA8000     ULNK
00090C  060000     RETURN
164:               
165:               void  TMR1_SetInterruptHandler(void (* InterruptHandler)(void))
166:               { 
00090E  FA0002     LNK #0x2
000910  780F00     MOV W0, [W14]
167:                   IEC0bits.T1IE = false;
000912  A96820     BCLR IEC0, #3
168:                   TMR1_InterruptHandler = InterruptHandler; 
000914  78009E     MOV [W14], W1
000916  888741     MOV W1, TMR1_InterruptHandler
169:                   IEC0bits.T1IE = true;
000918  A86820     BSET IEC0, #3
170:               }
00091A  FA8000     ULNK
00091C  060000     RETURN
171:               
172:               void TMR1_Start( void )
173:               {
00091E  FA0000     LNK #0x0
174:                   /* Reset the status information */
175:                   tmr1_obj.timerElapsed = false;
000920  EF70EA     CLR.B tmr1_obj
176:               
177:                   /*Enable the interrupt*/
178:                   IEC0bits.T1IE = true;
000922  A86820     BSET IEC0, #3
179:               
180:                   /* Start the Timer */
181:                   T1CONbits.TON = 1;
000924  A8E105     BSET 0x105, #7
182:               }
000926  FA8000     ULNK
000928  060000     RETURN
183:               
184:               void TMR1_Stop( void )
185:               {
00092A  FA0000     LNK #0x0
186:                   /* Stop the Timer */
187:                   T1CONbits.TON = false;
00092C  A9E105     BCLR 0x105, #7
188:               
189:                   /*Disable the interrupt*/
190:                   IEC0bits.T1IE = false;
00092E  A96820     BCLR IEC0, #3
191:               }
000930  FA8000     ULNK
000932  060000     RETURN
192:               
193:               bool TMR1_GetElapsedThenClear(void)
194:               {
000934  FA0002     LNK #0x2
195:                   bool status;
196:                   
197:                   status = tmr1_obj.timerElapsed;
000936  210EA1     MOV #0x10EA, W1
000938  784091     MOV.B [W1], W1
00093A  784F01     MOV.B W1, [W14]
198:               
199:                   if(status == true)
00093C  78401E     MOV.B [W14], W0
00093E  E00400     CP0.B W0
000940  320001     BRA Z, .L14
200:                   {
201:                       tmr1_obj.timerElapsed = false;
000942  EF70EA     CLR.B tmr1_obj
202:                   }
203:                   return status;
000944  78401E     MOV.B [W14], W0
204:               }
000946  FA8000     ULNK
000948  060000     RETURN
205:               
206:               int TMR1_SoftwareCounterGet(void)
207:               {
00094A  FA0000     LNK #0x0
208:                   return tmr1_obj.count;
00094C  BFD0EB     MOV.B 0x10EB, WREG
00094E  FB8000     ZE W0, W0
209:               }
000950  FA8000     ULNK
000952  060000     RETURN
210:               
211:               void TMR1_SoftwareCounterClear(void)
212:               {
000954  FA0000     LNK #0x0
213:                   tmr1_obj.count = 0; 
000956  EF70EB     CLR.B 0x10EB
214:               }
000958  FA8000     ULNK
00095A  060000     RETURN
215:               
216:               /**
217:                End of File
218:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/system.h  -------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the system.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "xc.h"
46:                #include "stdint.h"
47:                #include "system_types.h"
48:                
49:                #ifndef SYSTEM_H
50:                #define	SYSTEM_H
51:                /**
52:                 * Initializes the CPU core control register.
53:                 * @example
54:                 * <code>
55:                 * SYSTEM_CORCONInitialize();
56:                 * </code>
57:                 */
58:                inline static void SYSTEM_CORCONInitialize()
59:                {
60:                    CORCON = (CORCON & 0x00F2) | CORCON_MODE_PORVALUES;    // POR value
61:                }
62:                
63:                /**
64:                 * Sets the CPU core control register operating mode to a value that is decided by the
65:                 * SYSTEM_CORCON_MODES argument.
66:                 * @param modeValue SYSTEM_CORCON_MODES initialization mode specifier
67:                 * @example
68:                 * <code>
69:                 * SYSTEM_CORCONModeOperatingSet(CORCON_MODE_ENABLEALLSATNORMAL_ROUNDUNBIASED);
70:                 * </code>
71:                 */
72:                inline static void SYSTEM_CORCONModeOperatingSet(SYSTEM_CORCON_MODES modeValue)
73:                {
000A48  FA0002     LNK #0x2
000A4A  780F00     MOV W0, [W14]
74:                    CORCON = (CORCON & 0x00F2) | modeValue;
000A4C  800221     MOV CORCON, W1
000A4E  200F20     MOV #0xF2, W0
000A50  608000     AND W1, W0, W0
000A52  70001E     IOR W0, [W14], W0
000A54  880220     MOV W0, CORCON
75:                }
000A56  FA8000     ULNK
000A58  060000     RETURN
76:                
77:                /**
78:                 * Sets the value of CPU core control register.
79:                 * @param value value that needs to be written to the CPU core control register
80:                 * @example
81:                 * <code>
82:                 *  SYSTEM_CORCONRegisterValueSet(0x00E2);
83:                 * </code>
84:                 */
85:                inline static void SYSTEM_CORCONRegisterValueSet(uint16_t value)
86:                {
87:                    CORCON = value;
88:                }
89:                
90:                /**
91:                 * Gets the value of CPU core control register.
92:                 * @return value of the CPU core control register
93:                 * @example
94:                 * <code>
95:                 * corconSave = SYSTEM_CORCONRegisterValueGet();
96:                 * </code>
97:                 */
98:                inline static uint16_t SYSTEM_CORCONRegisterValueGet(void)
99:                {    
100:                   return CORCON;
101:               }
102:               
103:               
104:               /**
105:                * Gets the base address of the DEVID register for the currently selected device
106:                * @return base address of the DEVID register
107:                * @example
108:                * <code>
109:                * uint32_t devIdAddress;
110:                * devIdAddress = SYSTEM_DeviceIdRegisterAddressGet();
111:                * </code>
112:                */
113:               inline static uint32_t SYSTEM_DeviceIdRegisterAddressGet(void)
114:               {
115:                   return __DEVID_BASE;
116:               }
117:               
118:               /**
119:                * @Param
120:                   none
121:                * @Returns
122:                   none
123:                * @Description
124:                   Initializes the device to the default states configured in the
125:                *                  MCC GUI
126:                * @Example
127:                   SYSTEM_Initialize(void);
128:                */
129:               void SYSTEM_Initialize(void);
130:               #endif	/* SYSTEM_H */
131:               /**
132:                End of File
133:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/system.c  -------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "pin_manager.h"
46:                #include "clock.h"
47:                #include "system.h"
48:                #include "system_types.h"
49:                #include "interrupt_manager.h"
50:                #include "traps.h"
51:                #include "adc1.h"
52:                #include "tmr1.h"
53:                #include "tmr3.h"
54:                
55:                
56:                void SYSTEM_Initialize(void)
57:                {
000A66  FA0000     LNK #0x0
58:                    PIN_MANAGER_Initialize();
000A68  070021     RCALL PIN_MANAGER_Initialize
59:                    INTERRUPT_Initialize();
000A6A  070052     RCALL INTERRUPT_Initialize
60:                    CLOCK_Initialize();
000A6C  07FED5     RCALL CLOCK_Initialize
61:                    ADC1_Initialize();
000A6E  07FFC0     RCALL ADC1_Initialize
62:                    TMR1_Initialize();
000A70  07FF25     RCALL TMR1_Initialize
63:                    TMR3_Initialize();
000A72  07FF74     RCALL TMR3_Initialize
64:                    INTERRUPT_GlobalEnable();
000A74  07FFF2     RCALL _INTERRUPT_GlobalEnable, .LFE1, .LFB5
65:                    SYSTEM_CORCONModeOperatingSet(CORCON_MODE_PORVALUES);
000A76  200200     MOV #0x20, W0
000A78  07FFE7     RCALL _SYSTEM_CORCONModeOperatingSet, .Ltext0, .LFB1, .Letext0, .LFE24
66:                }
000A7A  FA8000     ULNK
000A7C  060000     RETURN
67:                
68:                /**
69:                 End of File
70:                */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/reset.c  --------
1:                 /**
2:                   RESET Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     reset.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the RESET driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for RESET.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdbool.h>
46:                #include <stdint.h>
47:                #include "xc.h"
48:                #include "reset.h"
49:                
50:                /**
51:                 Section: Local Variables
52:                */
53:                
54:                /**
55:                 Section: Function prototypes
56:                */
57:                static bool RESET_CauseFromSoftware(uint16_t resetCause);
58:                static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause);
59:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause);
60:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause);
61:                static bool RESET_CauseFromExternal(uint16_t resetCause);
62:                static bool RESET_CauseFromTrap(uint16_t resetCause);
63:                static void RESET_CauseClear(RESET_MASKS resetFlagMask);
64:                
65:                uint16_t RESET_GetCause(void)
66:                {
000630  FA0000     LNK #0x0
67:                    return RCON;
000632  803A00     MOV RCON, W0
68:                }
000634  FA8000     ULNK
000636  060000     RETURN
69:                
70:                void __attribute__ ((weak)) RESET_CauseHandler(void)
71:                {
000638  FA0002     LNK #0x2
72:                    uint16_t resetCause = RESET_GetCause();
00063A  07FFFA     RCALL RESET_GetCause
00063C  780F00     MOV W0, [W14]
73:                    if(RESET_CauseFromTrap(resetCause))
00063E  78001E     MOV [W14], W0
000640  070024     RCALL _RESET_CauseFromTrap, .LFE1, .LFB2
000642  E00400     CP0.B W0
000644  320002     BRA Z, .L3
74:                    { 
75:                      RESET_CauseClear(RESET_MASK_TRAPR); 
000646  280000     MOV #0x8000, W0
000648  070071     RCALL _RESET_CauseClear, .LFE7, .LFB8
76:                      //Do something 
77:                    }
78:                    if(RESET_CauseFromIllegalOpcode(resetCause))
00064A  78001E     MOV [W14], W0
00064C  07002A     RCALL _RESET_CauseFromIllegalOpcode, .LFE2, .LFB3
00064E  E00400     CP0.B W0
000650  320002     BRA Z, .L4
79:                    { 
80:                      RESET_CauseClear(RESET_MASK_IOPUWR); 
000652  240000     MOV #0x4000, W0
000654  07006B     RCALL _RESET_CauseClear, .LFE7, .LFB8
81:                      //Do something 
82:                    }
83:                    if(RESET_CauseFromConfigurationMismatch(resetCause))
000656  78001E     MOV [W14], W0
000658  070032     RCALL _RESET_CauseFromConfigurationMismatch, .LFE3, .LFB4
00065A  E00400     CP0.B W0
00065C  320002     BRA Z, .L5
84:                    { 
85:                      RESET_CauseClear(RESET_MASK_CM); 
00065E  202000     MOV #0x200, W0
000660  070065     RCALL _RESET_CauseClear, .LFE7, .LFB8
86:                      //Do something 
87:                    }
88:                    if(RESET_CauseFromExternal(resetCause))
000662  78001E     MOV [W14], W0
000664  07003A     RCALL _RESET_CauseFromExternal, .LFE4, .LFB5
000666  E00400     CP0.B W0
000668  320002     BRA Z, .L6
89:                    { 
90:                      RESET_CauseClear(RESET_MASK_EXTR); 
00066A  200800     MOV #0x80, W0
00066C  07005F     RCALL _RESET_CauseClear, .LFE7, .LFB8
91:                      //Do something 
92:                    }
93:                    if(RESET_CauseFromSoftware(resetCause))
00066E  78001E     MOV [W14], W0
000670  070042     RCALL _RESET_CauseFromSoftware, .LFE5, .LFB6
000672  E00400     CP0.B W0
000674  320002     BRA Z, .L7
94:                    { 
95:                      RESET_CauseClear(RESET_MASK_SWR); 
000676  200400     MOV #0x40, W0
000678  070059     RCALL _RESET_CauseClear, .LFE7, .LFB8
96:                      //Do something 
97:                    }
98:                    if(RESET_CauseFromWatchdogTimer(resetCause))
00067A  78001E     MOV [W14], W0
00067C  07004A     RCALL _RESET_CauseFromWatchdogTimer, .LFE6, .LFB7
00067E  E00400     CP0.B W0
000680  320002     BRA Z, .L2
99:                    { 
100:                     RESET_CauseClear(RESET_MASK_WDTO); 
000682  200100     MOV #0x10, W0
000684  070053     RCALL _RESET_CauseClear, .LFE7, .LFB8
101:                     //Do something 
102:                   }
103:               }
000686  FA8000     ULNK
000688  060000     RETURN
104:               
105:               static bool RESET_CauseFromTrap(uint16_t resetCause)
106:               {
00068A  FA0004     LNK #0x4
00068C  980710     MOV W0, [W14+2]
107:                   bool resetStatus = false;
00068E  EB4000     CLR.B W0
000690  784F00     MOV.B W0, [W14]
108:                   if(resetCause & RESET_MASK_TRAPR)
000692  90001E     MOV [W14+2], W0
000694  E00000     CP0 W0
000696  3D0002     BRA GE, .L10
109:                   { 
110:                     resetStatus = true; 
000698  B3C010     MOV.B #0x1, W0
00069A  784F00     MOV.B W0, [W14]
111:                   }
112:                   return resetStatus;
00069C  78401E     MOV.B [W14], W0
113:               }
00069E  FA8000     ULNK
0006A0  060000     RETURN
114:               
115:               static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
116:               {
0006A2  FA0004     LNK #0x4
0006A4  980710     MOV W0, [W14+2]
117:                   bool resetStatus = false;
0006A6  EB4000     CLR.B W0
0006A8  784F00     MOV.B W0, [W14]
118:                   if(resetCause & RESET_MASK_IOPUWR)
0006AA  90009E     MOV [W14+2], W1
0006AC  240000     MOV #0x4000, W0
0006AE  608000     AND W1, W0, W0
0006B0  E00000     CP0 W0
0006B2  320002     BRA Z, .L12
119:                   { 
120:                     resetStatus = true; 
0006B4  B3C010     MOV.B #0x1, W0
0006B6  784F00     MOV.B W0, [W14]
121:                   }
122:                   return resetStatus;
0006B8  78401E     MOV.B [W14], W0
123:               }
0006BA  FA8000     ULNK
0006BC  060000     RETURN
124:               
125:               static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
126:               {
0006BE  FA0004     LNK #0x4
0006C0  980710     MOV W0, [W14+2]
127:                   bool resetStatus = false;
0006C2  EB4000     CLR.B W0
0006C4  784F00     MOV.B W0, [W14]
128:                   if(resetCause & RESET_MASK_CM)
0006C6  90009E     MOV [W14+2], W1
0006C8  202000     MOV #0x200, W0
0006CA  608000     AND W1, W0, W0
0006CC  E00000     CP0 W0
0006CE  320002     BRA Z, .L14
129:                   { 
130:                     resetStatus = true; 
0006D0  B3C010     MOV.B #0x1, W0
0006D2  784F00     MOV.B W0, [W14]
131:                   }
132:                   return resetStatus;
0006D4  78401E     MOV.B [W14], W0
133:               }
0006D6  FA8000     ULNK
0006D8  060000     RETURN
134:               
135:               static bool RESET_CauseFromExternal(uint16_t resetCause)
136:               {
0006DA  FA0004     LNK #0x4
0006DC  980710     MOV W0, [W14+2]
137:                   bool resetStatus = false;
0006DE  EB4000     CLR.B W0
0006E0  784F00     MOV.B W0, [W14]
138:                   if(resetCause & RESET_MASK_EXTR)
0006E2  90009E     MOV [W14+2], W1
0006E4  200800     MOV #0x80, W0
0006E6  608000     AND W1, W0, W0
0006E8  E00000     CP0 W0
0006EA  320002     BRA Z, .L16
139:                   { 
140:                     resetStatus = true; 
0006EC  B3C010     MOV.B #0x1, W0
0006EE  784F00     MOV.B W0, [W14]
141:                   }
142:                   return resetStatus;
0006F0  78401E     MOV.B [W14], W0
143:               }
0006F2  FA8000     ULNK
0006F4  060000     RETURN
144:               
145:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
146:               {
0006F6  FA0004     LNK #0x4
0006F8  980710     MOV W0, [W14+2]
147:                   bool resetStatus = false;
0006FA  EB4000     CLR.B W0
0006FC  784F00     MOV.B W0, [W14]
148:                   if(resetCause & RESET_MASK_SWR)
0006FE  90009E     MOV [W14+2], W1
000700  200400     MOV #0x40, W0
000702  608000     AND W1, W0, W0
000704  E00000     CP0 W0
000706  320002     BRA Z, .L18
149:                   { 
150:                     resetStatus = true; 
000708  B3C010     MOV.B #0x1, W0
00070A  784F00     MOV.B W0, [W14]
151:                   }
152:                   return resetStatus;
00070C  78401E     MOV.B [W14], W0
153:               }
00070E  FA8000     ULNK
000710  060000     RETURN
154:               
155:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
156:               {
000712  FA0004     LNK #0x4
000714  980710     MOV W0, [W14+2]
157:                   bool resetStatus = false;
000716  EB4000     CLR.B W0
000718  784F00     MOV.B W0, [W14]
158:                   if(resetCause & RESET_MASK_WDTO)
00071A  90001E     MOV [W14+2], W0
00071C  600070     AND W0, #0x10, W0
00071E  E00000     CP0 W0
000720  320002     BRA Z, .L20
159:                   { 
160:                     resetStatus = true;
000722  B3C010     MOV.B #0x1, W0
000724  784F00     MOV.B W0, [W14]
161:                   }
162:                   return resetStatus;
000726  78401E     MOV.B [W14], W0
163:               }
000728  FA8000     ULNK
00072A  060000     RETURN
164:               
165:               static void RESET_CauseClear(RESET_MASKS resetFlagMask)
166:               { 
00072C  FA0002     LNK #0x2
00072E  780F00     MOV W0, [W14]
167:                    RCON = RCON & (~resetFlagMask); 
000730  EA809E     COM [W14], W1
000732  803A00     MOV RCON, W0
000734  608000     AND W1, W0, W0
000736  883A00     MOV W0, RCON
168:               } 
000738  FA8000     ULNK
00073A  060000     RETURN
169:               
170:               void RESET_CauseClearAll()
171:               { 
00073C  FA0000     LNK #0x0
172:                   RCON = 0x00; 
00073E  EF2740     CLR RCON
173:               }
000740  FA8000     ULNK
000742  060000     RETURN
174:               /**
175:                End of File
176:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/pin_manager.c  --
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
19:                        Device            :  dsPIC33EV32GM102
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.36B
22:                        MPLAB 	          :  MPLAB X v5.20
23:                */
24:                
25:                /*
26:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include "xc.h"
53:                #include <stdio.h>
54:                #include "pin_manager.h"
55:                
56:                /**
57:                 Section: File specific functions
58:                */
59:                
60:                /**
61:                 Section: Driver Interface Function Definitions
62:                */
63:                void PIN_MANAGER_Initialize (void)
64:                {
000AAC  FA0000     LNK #0x0
65:                    /****************************************************************************
66:                     * Setting the Output Latch SFR(s)
67:                     ***************************************************************************/
68:                    LATA = 0x0000;
000AAE  EF2E04     CLR LATA
69:                    LATB = 0x0000;
000AB0  EF2E18     CLR LATB
70:                
71:                    /****************************************************************************
72:                     * Setting the GPIO Direction SFR(s)
73:                     ***************************************************************************/
74:                    TRISA = 0x0017;
000AB2  200170     MOV #0x17, W0
000AB4  887000     MOV W0, TRISA
75:                    TRISB = 0x0FFF;
000AB6  20FFF0     MOV #0xFFF, W0
000AB8  8870A0     MOV W0, TRISB
76:                
77:                    /****************************************************************************
78:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
79:                     ***************************************************************************/
80:                    CNPDA = 0x000D;
000ABA  2000D0     MOV #0xD, W0
000ABC  887060     MOV W0, CNPDA
81:                    CNPDB = 0x0000;
000ABE  EF2E20     CLR CNPDB
82:                    CNPUA = 0x0000;
000AC0  EF2E0A     CLR CNPUA
83:                    CNPUB = 0x0000;
000AC2  EF2E1E     CLR CNPUB
84:                
85:                    /****************************************************************************
86:                     * Setting the Open Drain SFR(s)
87:                     ***************************************************************************/
88:                    ODCA = 0x0000;
000AC4  EF2E06     CLR ODCA
89:                    ODCB = 0x0000;
000AC6  EF2E1A     CLR ODCB
90:                
91:                    /****************************************************************************
92:                     * Setting the Analog/Digital Configuration SFR(s)
93:                     ***************************************************************************/
94:                    ANSELA = 0x0010;
000AC8  200100     MOV #0x10, W0
000ACA  887070     MOV W0, ANSELA
95:                    ANSELB = 0x0383;
000ACC  203830     MOV #0x383, W0
000ACE  887110     MOV W0, ANSELB
96:                
97:                
98:                
99:                }
000AD0  FA8000     ULNK
000AD2  060000     RETURN
100:               
101:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/mcc.c  ----------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     mcc.c
9:                 
10:                  @Summary:
11:                    This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    //Boot Segment Write-Protect Bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    //Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSS2 = OFF    //Boot Segment Control Bit->No Boot Segment
51:                #pragma config GWRP = OFF    //General Segment Write-Protect Bit->General Segment may be written
52:                #pragma config GSS = DISABLED    //General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    //Configuration Segment Write-Protect Bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    //Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = DISABLE    //Alternate Interrupt Vector Table Disable Bit ->Disable Alternate Vector Table
56:                
57:                // FBSLIM
58:                #pragma config BSLIM = 8191    //Boot Segment Code Flash Page Address Limit Bits->8191
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCDIVN    //Initial oscillator Source Selection Bits->Internal Fast RC (FRC) Oscillator with postscaler
62:                #pragma config IESO = OFF    //Two Speed Oscillator Start-Up Bit->Start up device with user selected oscillator source
63:                
64:                // FOSC
65:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select Bits->Primary Oscillator disabled
66:                #pragma config OSCIOFNC = ON    //OSC2 Pin I/O Function Enable Bit->OSC2 is general purpose digital I/O pin
67:                #pragma config IOL1WAY = ON    //Peripheral Pin Select Configuration Bit->Allow Only One reconfiguration
68:                #pragma config FCKSM = CSECMD    //Clock Switching Mode Bits->Clock Switching is enabled,Fail-safe Clock Monitor is disabled
69:                #pragma config PLLKEN = ON    //PLL Lock Enable Bit->Clock switch to PLL source will wait until the PLL lock signal is valid
70:                
71:                // FWDT
72:                #pragma config WDTPOST = PS32768    //Watchdog Timer Postscaler Bits->1:32768
73:                #pragma config WDTPRE = PR128    //Watchdog Timer Prescaler Bit->1:128
74:                #pragma config FWDTEN = OFF    //Watchdog Timer Enable Bits->WDT and SWDTEN Disabled
75:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable Bit->Watchdog timer in Non-Window Mode
76:                #pragma config WDTWIN = WIN25    //Watchdog Window Select Bits->WDT Window is 25% of WDT period
77:                
78:                // FPOR
79:                #pragma config BOREN0 = ON    //Brown Out Reset Detection Bit->BOR is Enabled
80:                
81:                // FICD
82:                #pragma config ICS = PGD1    //ICD Communication Channel Select Bits->Communicate on PGEC1 and PGED1
83:                
84:                // FDMTINTVL
85:                #pragma config DMTIVTL = 0    //Lower 16 Bits of 32 Bit DMT Window Interval->0
86:                
87:                // FDMTINTVH
88:                #pragma config DMTIVTH = 0    //Upper 16 Bits of 32 Bit DMT Window Interval->0
89:                
90:                // FDMTCNTL
91:                #pragma config DMTCNTL = 0    //Lower 16 Bits of 32 Bit DMT Instruction Count Time-Out Value->0
92:                
93:                // FDMTCNTH
94:                #pragma config DMTCNTH = 0    //Upper 16 Bits of 32 Bit DMT Instruction Count Time-Out Value->0
95:                
96:                // FDMT
97:                #pragma config DMTEN = DISABLE    //Dead Man Timer Enable Bit->Dead Man Timer is Disabled and can be enabled by software
98:                
99:                // FDEVOPT
100:               #pragma config PWMLOCK = ON    //PWM Lock Enable Bit->Certain PWM registers may only be written after key sequence
101:               #pragma config ALTI2C1 = OFF    //Alternate I2C1 Pins Selection Bit->I2C1 mapped to SDA1/SCL1 pins
102:               
103:               // FALTREG
104:               #pragma config CTXT1 = NONE    //Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 1->Not Assigned
105:               #pragma config CTXT2 = NONE    //Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 2->Not Assigned
106:               
107:               #include "mcc.h"
108:               #include "reset.h"
109:               #include "clock.h"
110:               
111:               /**
112:                Section: Local Variables
113:               */
114:               
115:               /**
116:                Section: Function prototypes
117:               */
118:               
119:               /**
120:               * a private place to store the error code if we run into a severe error
121:               */
122:               
123:               void OSCILLATOR_Initialize(void)
124:               {
000AD4  FA0000     LNK #0x0
125:                   CLOCK_Initialize();
000AD6  07FEA0     RCALL CLOCK_Initialize
126:               }
000AD8  FA8000     ULNK
000ADA  060000     RETURN
127:               
128:               uint16_t SYSTEM_GetResetCause(void)
129:               {
000ADC  FA0000     LNK #0x0
130:                   return RCON;
000ADE  803A00     MOV RCON, W0
131:               }
000AE0  FA8000     ULNK
000AE2  060000     RETURN
132:               
133:               void __attribute__ ((weak)) SYSTEM_ResetCauseHandler(void)
134:               {
000AE4  FA0000     LNK #0x0
135:                   RESET_CauseHandler();
000AE6  07FDA8     RCALL RESET_CauseHandler
136:               }
000AE8  FA8000     ULNK
000AEA  060000     RETURN
137:               
138:               void SYSTEM_ResetCauseClearAll()
139:               { 
000AEC  FA0000     LNK #0x0
140:                   RESET_CauseClearAll();
000AEE  07FE26     RCALL RESET_CauseClearAll
141:               }
000AF0  FA8000     ULNK
000AF2  060000     RETURN
142:               /**
143:                End of File
144:               */
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/interrupt_manager.h
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _INTERRUPT_MANAGER_H
46:                #define _INTERRUPT_MANAGER_H
47:                
48:                /**
49:                  @Summary
50:                    Initializes the interrupt priorities of the dsPIC33EV32GM102
51:                
52:                  @Description
53:                    This routine sets the interrupt priorities of the modules that have been configured
54:                    for the dsPIC33EV32GM102
55:                
56:                  @Preconditions
57:                    None.
58:                
59:                  @Returns
60:                    None.
61:                
62:                  @Param
63:                    None.
64:                
65:                  @Example
66:                    <code>
67:                    void SYSTEM_Initialize(void)
68:                    {
69:                        // Other initializers are called from this function
70:                        INTERRUPT_Initialize ();
71:                    }
72:                    </code>
73:                
74:                */
75:                void INTERRUPT_Initialize(void);
76:                
77:                /**
78:                  @Summary
79:                    Enables global interrupts of the dsPIC33EV32GM102
80:                
81:                  @Description
82:                    This routine enables the global interrupt bit for the dsPIC33EV32GM102
83:                
84:                  @Preconditions
85:                    None.
86:                
87:                  @Returns
88:                    None.
89:                
90:                  @Param
91:                    None.
92:                
93:                  @Example
94:                    <code>
95:                    void SYSTEM_Initialize(void)
96:                    {
97:                        // Other initializers are called from this function
98:                        INTERRUPT_GlobalEnable ();
99:                    }
100:                   </code>
101:               
102:               */
103:               inline static void INTERRUPT_GlobalEnable(void)
104:               {
000A5A  FA0000     LNK #0x0
105:                   __builtin_enable_interrupts();
000A5C  A8E8C3     BSET 0x8C3, #7
000A5E  000000     NOP
000A60  000000     NOP
106:               }
000A62  FA8000     ULNK
000A64  060000     RETURN
107:               
108:               /**
109:                 @Summary
110:                   Disables global interrupts of the dsPIC33EV32GM102
111:               
112:                 @Description
113:                   This routine disables the global interrupt bit for the dsPIC33EV32GM102
114:               
115:                 @Preconditions
116:                   None.
117:               
118:                 @Returns
119:                   None.
120:               
121:                 @Param
122:                   None.
123:               
124:                 @Example
125:                   <code>
126:                   void SYSTEM_Initialize(void)
127:                   {
128:                       // Other initializers are called from this function
129:                       INTERRUPT_GlobalDisable ();
130:                   }
131:                   </code>
132:               
133:               */
134:               inline static void INTERRUPT_GlobalDisable(void)
135:               {
136:                   __builtin_disable_interrupts();
137:               }
138:               
139:               
140:               #endif
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/interrupt_manager.c
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB             :  MPLAB X v5.20
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
000B10  FA0000     LNK #0x0
55:                    //    ADI: ADC1 Convert Done
56:                    //    Priority: 1
57:                        IPC3bits.AD1IP = 1;
000B12  804231     MOV IPC3, W1
000B14  2FF8F0     MOV #0xFF8F, W0
000B16  608000     AND W1, W0, W0
000B18  A04000     BSET W0, #4
000B1A  884230     MOV W0, IPC3
58:                    //    TI: Timer 1
59:                    //    Priority: 1
60:                        IPC0bits.T1IP = 1;
000B1C  804201     MOV IPC0, W1
000B1E  28FFF0     MOV #0x8FFF, W0
000B20  608000     AND W1, W0, W0
000B22  A0C000     BSET W0, #12
000B24  884200     MOV W0, IPC0
61:                }
000B26  FA8000     ULNK
000B28  060000     RETURN
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/mcc_generated_files/clock.c  --------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB             :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                #include <math.h>
49:                
50:                // ADC clock variables
51:                #define TAD_MIN_US      75     
52:                uint16_t TAD_ns;            // nanoseconds
53:                uint16_t TAD_multiplier;
54:                
55:                
56:                void CLOCK_Initialize(void)
57:                {
000818  FA0000     LNK #0x0
58:                    // FRCDIV FRC/1; PLLPRE 2; DOZE 1:8; PLLPOST 1:2; DOZEN disabled; ROI disabled; 
59:                    CLKDIV = 0x3000;
00081A  230000     MOV #0x3000, W0
00081C  883A20     MOV W0, CLKDIV
60:                    // TUN Center frequency; 
61:                    OSCTUN = 0x00;
00081E  EF2748     CLR OSCTUN
62:                    // ROON disabled; ROSEL FOSC; RODIV 0; ROSSLP disabled; 
63:                    REFOCON = 0x00;
000820  EF274E     CLR REFOCON
64:                    // PLLDIV 50; 
65:                    PLLFBD = 0x32;
000822  200320     MOV #0x32, W0
000824  883A30     MOV W0, PLLFBD
66:                    // AD1MD enabled; PWMMD enabled; T3MD enabled; T4MD enabled; T1MD enabled; U2MD enabled; T2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; C1MD enabled; T5MD enabled; I2C1MD enabled; 
67:                    PMD1 = 0x00;
000826  EF2760     CLR PMD1
68:                    // IC4MD enabled; IC3MD enabled; OC1MD enabled; IC2MD enabled; OC2MD enabled; IC1MD enabled; OC3MD enabled; OC4MD enabled; 
69:                    PMD2 = 0x00;
000828  EF2762     CLR PMD2
70:                    // CMPMD enabled; 
71:                    PMD3 = 0x00;
00082A  EF2764     CLR PMD3
72:                    // CTMUMD enabled; REFOMD enabled; 
73:                    PMD4 = 0x00;
00082C  EF2766     CLR PMD4
74:                    // PWM2MD enabled; PWM1MD enabled; PWM3MD enabled; 
75:                    PMD6 = 0x00;
00082E  EF276A     CLR PMD6
76:                    // DMA0MD enabled; 
77:                    PMD7 = 0x00;
000830  EF276C     CLR PMD7
78:                    // DMTMD enabled; SENT2MD enabled; SENT1MD enabled; 
79:                    PMD8 = 0x00;
000832  EF276E     CLR PMD8
80:                    // CF no clock failure; NOSC FRCDIV; CLKLOCK unlocked; OSWEN Switch is Complete; 
81:                    __builtin_write_OSCCONH((uint8_t) (0x07));
000834  200072     MOV #0x7, W2
000836  200780     MOV #0x78, W0
000838  2009A1     MOV #0x9A, W1
00083A  207433     MOV #0x743, W3
00083C  784980     MOV.B W0, [W3]
00083E  784981     MOV.B W1, [W3]
000840  784982     MOV.B W2, [W3]
82:                    __builtin_write_OSCCONL((uint8_t) (0x00));
000842  EB0100     CLR W2
000844  200460     MOV #0x46, W0
000846  200571     MOV #0x57, W1
000848  207423     MOV #0x742, W3
00084A  784980     MOV.B W0, [W3]
00084C  784981     MOV.B W1, [W3]
00084E  784982     MOV.B W2, [W3]
83:                }
000850  FA8000     ULNK
000852  060000     RETURN
84:                
85:                
86:                uint16_t CLOCK_PeriodnsGet(void) {
000854  FA0000     LNK #0x0
87:                    return ceil(1 / (CLOCK_InstructionFrequencyGet() * 0.000000001));
000856  201100     MOV #0x110, W0
88:                }
000858  FA8000     ULNK
00085A  060000     RETURN
89:                
90:                
91:                uint16_t ADC1CLOCK_GENMultiplier(void) {
00085C  FA0002     LNK #0x2
92:                    uint16_t T_instruction_ns = CLOCK_PeriodnsGet();
00085E  07FFFA     RCALL CLOCK_PeriodnsGet
000860  780F00     MOV W0, [W14]
93:                    if (T_instruction_ns < TAD_MIN_US) {
000862  2004A0     MOV #0x4A, W0
000864  78009E     MOV [W14], W1
000866  508F80     SUB W1, W0, [W15]
000868  3E000C     BRA GTU, .L4
94:                        TAD_multiplier = ceil(TAD_MIN_US / T_instruction_ns);
00086A  2004B1     MOV #0x4B, W1
00086C  78001E     MOV [W14], W0
00086E  780100     MOV W0, W2
000870  090011     REPEAT #0x11
000872  D88082     DIV.UW W1, W2
000874  EB0080     CLR W1
000876  07FDFA     RCALL ___floatunsisf
000878  07FDAF     RCALL _ceilf
00087A  07FDDD     RCALL ___fixunssfsi
00087C  780000     MOV W0, W0
00087E  888730     MOV W0, TAD_multiplier
000880  370001     BRA .L5
95:                    }
96:                    else {
97:                        TAD_multiplier = 0;
000882  EF30E6     CLR TAD_multiplier
98:                    }
99:                    
100:                   TAD_ns = T_instruction_ns * (1 + TAD_multiplier);
000884  808730     MOV TAD_multiplier, W0
000886  E80080     INC W0, W1
000888  78001E     MOV [W14], W0
00088A  B98880     MULW.SS W1, W0, W0
00088C  888720     MOV W0, TAD_ns
101:                   
102:                   return TAD_multiplier;
00088E  808730     MOV TAD_multiplier, W0
103:               }
000890  FA8000     ULNK
000892  060000     RETURN
104:               
105:               
106:               uint16_t ADC1CLOCK_PeriodnsGet(void) {
000894  FA0000     LNK #0x0
107:                   return TAD_ns;
000896  808720     MOV TAD_ns, W0
108:               }
000898  FA8000     ULNK
00089A  060000     RETURN
109:               
110:               uint16_t ADC1CLOCK_MultiplierGet(void) {
00089C  FA0000     LNK #0x0
111:                   return TAD_multiplier;
00089E  808730     MOV TAD_multiplier, W0
112:               }
0008A0  FA8000     ULNK
0008A2  060000     RETURN
113:               
114:               void ADC1CLOCK_PeriodnsSet(uint16_t period_ns) {
0008A4  FA0002     LNK #0x2
0008A6  780F00     MOV W0, [W14]
115:                   TAD_ns = period_ns;
0008A8  78009E     MOV [W14], W1
0008AA  888721     MOV W1, TAD_ns
116:               }
0008AC  FA8000     ULNK
0008AE  060000     RETURN
117:               
118:               void ADC1CLOCK_MultiplierSet(uint16_t multiplier) {
0008B0  FA0002     LNK #0x2
0008B2  780F00     MOV W0, [W14]
119:                   TAD_multiplier = multiplier;
0008B4  78009E     MOV [W14], W1
0008B6  888731     MOV W1, TAD_multiplier
120:               }
0008B8  FA8000     ULNK
0008BA  060000     RETURN
121:               
122:               
123:               
124:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/main.c  -----------------------------
1:                 /**
2:                   Generated main.c file from MPLAB Code Configurator
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     main.c
9:                 
10:                  @Summary
11:                    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.
12:                
13:                  @Description
14:                    This source file provides main entry point for system initialization and application code development.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
17:                        Device            :  dsPIC33EV32GM102
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.36B
20:                        MPLAB 	          :  MPLAB X v5.20
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include "mcc_generated_files/system.h"
49:                #include "mcc_generated_files/adc1.h"
50:                #include "calibration.h"
51:                #include "mcc_generated_files/tmr1.h"
52:                #include "mcc_generated_files/tmr3.h"
53:                
54:                #define NUM_CAL_POINTS      10              // Number of calibration points
55:                #define DIFFAMP_GAIN        80
56:                #define OPAMP_UNITY_GAIN    1
57:                #define R_SHUNT             0.004
58:                
59:                #define I_EFF_GAIN          DIFFAMP_GAIN * OPAMP_UNITY_GAIN;
60:                
61:                
62:                void TMR1_InterruptHandler_ADC1GO (void);
63:                // dummy functions for now - test basic functionality
64:                uint16_t ProcessCurrent(uint16_t);
65:                uint16_t ProcessVoltage(uint16_t);
66:                void CAN_send(uint16_t);    
67:                
68:                // current and voltage calibration data - ideal points need to be set
69:                cal_point_t current_cal_data[NUM_CAL_POINTS];
70:                cal_point_t voltage_cal_data[NUM_CAL_POINTS];
71:                
72:                /*
73:                                         Main application
74:                 */
75:                int main(void)
76:                {
000744  FA002A     LNK #0x2A
77:                    uint16_t current_readings[ADC_BUF_SIZE / 2];
78:                    uint16_t voltage_readings[ADC_BUF_SIZE / 2];
79:                    
80:                    uint16_t current_avg = 0;
000746  EB0000     CLR W0
000748  780F00     MOV W0, [W14]
81:                    uint16_t voltage_avg = 0;
00074A  EB0000     CLR W0
00074C  980710     MOV W0, [W14+2]
82:                    
83:                    // initialize the device
84:                    SYSTEM_Initialize();
00074E  07018B     RCALL SYSTEM_Initialize
85:                    TMR1_SetInterruptHandler(&TMR1_InterruptHandler_ADC1GO);
000750  207F20     MOV #0x7F2, W0
000752  0700DD     RCALL TMR1_SetInterruptHandler
000754  370001     BRA .L7
86:                    
87:                    while (1)
88:                    {
89:                        if (ADC1_IsDataReady() == true) {
000758  07016F     RCALL ADC1_IsDataReady
00075A  E00400     CP0.B W0
00075C  32FFFC     BRA Z, .L8
90:                            ADC1_AcknowledgeDataReady();  
00075E  070170     RCALL ADC1_AcknowledgeDataReady
91:                            
92:                            uint16_t *data = ADC1_GetBufferPtr(); 
000760  070167     RCALL ADC1_GetBufferPtr
000762  980730     MOV W0, [W14+6]
93:                            
94:                            // process sampled data
95:                            uint16_t buffer_index = 0;
000764  EB0000     CLR W0
000766  980740     MOV W0, [W14+8]
96:                            uint16_t i;
97:                            for (i = 0; i < ADC_BUF_SIZE / 2; i++) {
000768  EB0000     CLR W0
00076A  980720     MOV W0, [W14+4]
00076C  370023     BRA .L3
0007AE  90002E     MOV [W14+4], W0
0007B0  E80000     INC W0, W0
0007B2  980720     MOV W0, [W14+4]
0007B4  90002E     MOV [W14+4], W0
0007B6  500FE7     SUB W0, #0x7, [W15]
0007B8  36FFDA     BRA LEU, .L4
98:                                buffer_index = i * 2;
00076E  90002E     MOV [W14+4], W0
000770  400000     ADD W0, W0, W0
000772  980740     MOV W0, [W14+8]
99:                                current_readings[i] = ProcessCurrent(CalibrateData(data[buffer_index], current_cal_data, NUM_CAL_POINTS));   
000774  90004E     MOV [W14+8], W0
000776  400000     ADD W0, W0, W0
000778  9000BE     MOV [W14+6], W1
00077A  408000     ADD W1, W0, W0
00077C  780010     MOV [W0], W0
00077E  2000A2     MOV #0xA, W2
000780  210001     MOV #0x1000, W1
000782  0701B8     RCALL CalibrateData
000784  07003B     RCALL ProcessCurrent
000786  780080     MOV W0, W1
000788  90002E     MOV [W14+4], W0
00078A  400000     ADD W0, W0, W0
00078C  40006A     ADD W0, #0xA, W0
00078E  783701     MOV W1, [W14+W0]
100:                               voltage_readings[i] = ProcessVoltage(CalibrateData(data[buffer_index + 1], voltage_cal_data, NUM_CAL_POINTS));  
000790  90004E     MOV [W14+8], W0
000792  E80000     INC W0, W0
000794  400000     ADD W0, W0, W0
000796  9000BE     MOV [W14+6], W1
000798  408000     ADD W1, W0, W0
00079A  780010     MOV [W0], W0
00079C  2000A2     MOV #0xA, W2
00079E  210501     MOV #0x1050, W1
0007A0  0701A9     RCALL CalibrateData
0007A2  070031     RCALL ProcessVoltage
0007A4  780080     MOV W0, W1
0007A6  90002E     MOV [W14+4], W0
0007A8  400000     ADD W0, W0, W0
0007AA  40007A     ADD W0, #0x1A, W0
0007AC  783701     MOV W1, [W14+W0]
101:                           }
102:                           
103:                           // average data
104:                           for (i = 0; i < ADC_BUF_SIZE / 2; i++) {
0007BA  EB0000     CLR W0
0007BC  980720     MOV W0, [W14+4]
0007BE  37000F     BRA .L5
0007D8  90002E     MOV [W14+4], W0
0007DA  E80000     INC W0, W0
0007DC  980720     MOV W0, [W14+4]
0007DE  90002E     MOV [W14+4], W0
0007E0  500FE7     SUB W0, #0x7, [W15]
0007E2  36FFEE     BRA LEU, .L6
105:                               current_avg += current_readings[i];
0007C0  90002E     MOV [W14+4], W0
0007C2  400000     ADD W0, W0, W0
0007C4  40006A     ADD W0, #0xA, W0
0007C6  78006E     MOV [W14+W0], W0
0007C8  400F1E     ADD W0, [W14], [W14]
106:                               voltage_avg += voltage_readings[i];
0007CA  90002E     MOV [W14+4], W0
0007CC  400000     ADD W0, W0, W0
0007CE  40007A     ADD W0, #0x1A, W0
0007D0  78006E     MOV [W14+W0], W0
0007D2  90009E     MOV [W14+2], W1
0007D4  408000     ADD W1, W0, W0
0007D6  980710     MOV W0, [W14+2]
107:                           }
108:                           current_avg /= ADC_BUF_SIZE / 2;
0007E4  78001E     MOV [W14], W0
0007E6  DE0043     LSR W0, #3, W0
0007E8  780F00     MOV W0, [W14]
109:                           voltage_avg /= ADC_BUF_SIZE / 2;
0007EA  90001E     MOV [W14+2], W0
0007EC  DE0043     LSR W0, #3, W0
0007EE  980710     MOV W0, [W14+2]
110:                               
111:                           // send data over CAN
112:                           //CAN_send(current_avg);
113:                           //CAN_send(voltage_avg);
114:                       }
115:                   }
000756  000000     NOP
0007F0  37FFB3     BRA .L7
116:                   return 1; 
117:               }
118:               
119:               
120:               void TMR1_InterruptHandler_ADC1GO (void) {
0007F2  FA0000     LNK #0x0
121:                   // clears and starts timer 3 (stopped in ADC interrupt)
122:                   // timer 3 is the ADC conversion trigger (set for 15 TAD)
123:                   TMR3_SoftwareCounterClear();
0007F4  0700F9     RCALL TMR3_SoftwareCounterClear
124:                   TMR3_Start();
0007F6  0700DF     RCALL TMR3_Start
125:               }
0007F8  FA8000     ULNK
0007FA  060000     RETURN
126:               
127:               
128:               uint16_t ProcessCurrent(uint16_t data) {
0007FC  FA0002     LNK #0x2
0007FE  780F00     MOV W0, [W14]
129:                    return 0;
000800  EB0000     CLR W0
130:               }
000802  FA8000     ULNK
000804  060000     RETURN
131:               
132:               
133:               uint16_t ProcessVoltage(uint16_t data) {
000806  FA0002     LNK #0x2
000808  780F00     MOV W0, [W14]
134:                   // STUFF
135:                    return 0;
00080A  EB0000     CLR W0
136:               }
00080C  FA8000     ULNK
00080E  060000     RETURN
137:               
138:               
139:               void CAN_Send(uint16_t data) {
000810  FA0002     LNK #0x2
000812  780F00     MOV W0, [W14]
140:                   return;
141:               }
000814  FA8000     ULNK
000816  060000     RETURN
142:               
143:               /**
144:                End of File
145:               */
146:               
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/calibration.c  ----------------------
1:                 
2:                 #include "calibration.h"
3:                 
4:                 uint16_t CalibrateData(uint16_t data, cal_point_t* cal_data_points, uint16_t num_points){
000AF4  FA0006     LNK #0x6
000AF6  780F00     MOV W0, [W14]
000AF8  980711     MOV W1, [W14+2]
000AFA  980722     MOV W2, [W14+4]
5:                     return 0;
000AFC  EB0000     CLR W0
6:                 }
000AFE  FA8000     ULNK
000B00  060000     RETURN
7:                 
8:                 uint16_t RunCalibrationSetup(cal_point_t* cal_data_points, uint16_t num_points, uint16_t tolerance){
000B02  FA0006     LNK #0x6
000B04  780F00     MOV W0, [W14]
000B06  980711     MOV W1, [W14+2]
000B08  980722     MOV W2, [W14+4]
9:                     return 0;
000B0A  EB0000     CLR W0
10:                }
000B0C  FA8000     ULNK
000B0E  060000     RETURN
11:                
12:                
13:                //void __attribute__ ( ( __interrupt__ , auto_psv ) ) _AD1Interrupt ( void )
14:                //{
15:                //    // Disable timer 3 (ADC conversion trigger)
16:                //    TMR3_Stop();
17:                //    
18:                //	// ADC1 callback function 
19:                //	//ADC1_CallBack();
20:                //	
21:                //    // transfer ADC samples to buffer (could use DMA in the future)
22:                //    adc_buffer[0] = ADC1BUF0;
23:                //    adc_buffer[1] = ADC1BUF1;
24:                //    adc_buffer[2] = ADC1BUF2;
25:                //    adc_buffer[3] = ADC1BUF3;
26:                //    adc_buffer[4] = ADC1BUF4;
27:                //    adc_buffer[5] = ADC1BUF5;
28:                //    adc_buffer[6] = ADC1BUF6;
29:                //    adc_buffer[7] = ADC1BUF7;
30:                //    adc_buffer[8] = ADC1BUF8;
31:                //    adc_buffer[9] = ADC1BUF9;
32:                //    adc_buffer[10] = ADC1BUFA;
33:                //    adc_buffer[11] = ADC1BUFB;
34:                //    adc_buffer[12] = ADC1BUFC;
35:                //    adc_buffer[13] = ADC1BUFD;
36:                //    adc_buffer[14] = ADC1BUFE;
37:                //    adc_buffer[15] = ADC1BUFF;
38:                //    
39:                //    
40:                //    data_ready = true;
41:                //    
42:                //    // clear the ADC interrupt flag
43:                //    IFS0bits.AD1IF = false;
44:                //}
---  C:/Users/Paul/Documents/Git/HKN-SAE-Project/PowerSenseModule.X/adc1.c  -----------------------------
1:                 
2:                 /**
3:                   ADC1 Generated Driver File
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     adc1.c
10:                
11:                  @Summary
12:                    This is the generated header file for the ADC1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This header file provides APIs for driver for ADC1.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.125
18:                        Device            :  dsPIC33EV32GM102
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.36B
21:                        MPLAB 	          :  MPLAB X v5.20
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include "mcc_generated_files/adc1.h"
51:                #include "mcc_generated_files/tmr3.h"
52:                #include "mcc_generated_files/clock.h"
53:                
54:                bool data_ready = 0;
55:                uint16_t adc_buffer[ADC_BUF_SIZE] = { 0 };
56:                
57:                
58:                /**
59:                  Section: Data Type Definitions
60:                */
61:                
62:                /* ADC Driver Hardware Instance Object
63:                
64:                  @Summary
65:                    Defines the object required for the maintenance of the hardware instance.
66:                
67:                  @Description
68:                    This defines the object required for the maintenance of the hardware
69:                    instance. This object exists once per hardware instance of the peripheral.
70:                
71:                 */
72:                typedef struct
73:                {
74:                	uint8_t intSample;
75:                }
76:                
77:                ADC_OBJECT;
78:                
79:                static ADC_OBJECT adc1_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                */
84:                
85:                
86:                void ADC1_Initialize (void)
87:                {   
0009F0  FA0000     LNK #0x0
88:                    // ASAM enabled; ADDMABM disabled; ADSIDL disabled; DONE disabled; SIMSAM Simultaneous; FORM Absolute decimal result, unsigned, right-justified; SAMP disabled; SSRC TMR3; AD12B 10-bit; ADON enabled; SSRCG disabled; 
89:                
90:                   AD1CON1 = 0b1000000001001100;
0009F2  2804C0     MOV #0x804C, W0
0009F4  881900     MOV W0, AD1CON1
91:                
92:                    // CSCNA disabled; VCFG0 AVDD; VCFG1 AVSS; ALTS disabled; BUFM disabled; SMPI Generates interrupt after completion of every sample/conversion operation; CHPS 2 Channel; 
93:                
94:                   AD1CON2 = 0b000000100000000;
0009F6  201000     MOV #0x100, W0
0009F8  881910     MOV W0, AD1CON2
95:                   AD1CON2bits.SMPI = 2;
0009FA  801911     MOV AD1CON2, W1
0009FC  2FF830     MOV #0xFF83, W0
0009FE  608000     AND W1, W0, W0
000A00  A03000     BSET W0, #3
000A02  881910     MOV W0, AD1CON2
96:                
97:                    // SAMC 5; ADRC FOSC/2; ADCS 0; 
98:                
99:                   AD1CON3 = 0x000;
000A04  EF2324     CLR AD1CON3
100:                  AD1CON3bits.ADCS = ADC1CLOCK_GENMultiplier();
000A06  07FF2A     RCALL ADC1CLOCK_GENMultiplier
000A08  784000     MOV.B W0, W0
000A0A  B7E324     MOV.B WREG, AD1CON3
101:               
102:                   // CH0SA AN2; CH0SB AN2; CH0NB VREFL; CH0NA VREFL; 
103:               
104:                  AD1CHS0 = 0b0000001000000010;
000A0C  202020     MOV #0x202, W0
000A0E  881940     MOV W0, AD1CHS0
105:               
106:                   // CSS26 disabled; CSS25 disabled; CSS24 disabled; CSS27 disabled; 
107:               
108:                  AD1CSSH = 0x00;
000A10  EF232E     CLR AD1CSSH
109:               
110:                   // CSS2 disabled; CSS1 disabled; CSS0 disabled; CSS5 disabled; CSS4 disabled; CSS3 disabled; 
111:               
112:                  AD1CSSL = 0x00;
000A12  EF2330     CLR AD1CSSL
113:               
114:                   // DMABL Allocates 1 word of buffer to each analog input; ADDMAEN disabled; 
115:               
116:                  AD1CON4 = 0x00;
000A14  EF2332     CLR AD1CON4
117:               
118:                   // CH123SA2 CH1=OA1/AN3; CH123SB2 CH1=OA1/AN3; CH123NA CH1=VREF-; CH123NB CH1=VREF-; 
119:               
120:                  AD1CHS123 = 0x101;
000A16  201010     MOV #0x101, W0
000A18  881930     MOV W0, AD1CHS123
121:               
122:                  
123:                  adc1_obj.intSample = AD1CON2bits.SMPI;
000A1A  801910     MOV AD1CON2, W0
000A1C  DE0042     LSR W0, #2, W0
000A1E  60407F     AND.B W0, #0x1F, W0
000A20  B7F0C2     MOV.B WREG, adc1_obj
124:                  
125:                  data_ready = 0;
000A22  EF70A0     CLR.B data_ready
126:                          
127:                  // Enabling ADC1 interrupt.
128:                  IEC0bits.AD1IE = 1;
000A24  A8A821     BSET 0x821, #5
129:               
130:               }
000A26  FA8000     ULNK
000A28  060000     RETURN
131:               
132:               void __attribute__ ((weak)) ADC1_CallBack(void)
133:               {
000A2A  FA0000     LNK #0x0
134:                   // Add your custom callback code here
135:               }
000A2C  FA8000     ULNK
000A2E  060000     RETURN
136:               
137:               void __attribute__ ( ( __interrupt__ , auto_psv ) ) _AD1Interrupt ( void )
138:               {
00036C  781F80     MOV W0, [W15++]
00036E  F80032     PUSH DSRPAG
000370  F80034     PUSH DSWPAG
000372  200010     MOV #0x1, W0
000374  8801A0     MOV W0, DSWPAG
000376  200010     MOV #0x1, W0
000378  880190     MOV W0, DSRPAG
00037A  000000     NOP
00037C  FA0000     LNK #0x0
139:               	// ADC1 callback function 
140:               	//ADC1_CallBack();
141:               	
142:                   T3CONbits.TON = false;
00037E  A9E113     BCLR 0x113, #7
143:                   IFS0bits.T3IF = 0;
000380  A90801     BCLR 0x801, #0
144:                   
145:                   adc_buffer[0] = ADC1BUF0;
000382  801800     MOV ADC1BUF0, W0
000384  888510     MOV W0, adc_buffer
146:                   adc_buffer[1] = ADC1BUF1;
000386  801810     MOV ADC1BUF1, W0
000388  888520     MOV W0, 0x10A4
147:                   adc_buffer[2] = ADC1BUF2;
00038A  801820     MOV ADC1BUF2, W0
00038C  888530     MOV W0, 0x10A6
148:                   adc_buffer[3] = ADC1BUF3;
00038E  801830     MOV ADC1BUF3, W0
000390  888540     MOV W0, 0x10A8
149:                   adc_buffer[4] = ADC1BUF4;
000392  801840     MOV ADC1BUF4, W0
000394  888550     MOV W0, 0x10AA
150:                   adc_buffer[5] = ADC1BUF5;
000396  801850     MOV ADC1BUF5, W0
000398  888560     MOV W0, 0x10AC
151:                   adc_buffer[6] = ADC1BUF6;
00039A  801860     MOV ADC1BUF6, W0
00039C  888570     MOV W0, 0x10AE
152:                   adc_buffer[7] = ADC1BUF7;
00039E  801870     MOV ADC1BUF7, W0
0003A0  888580     MOV W0, 0x10B0
153:                   adc_buffer[8] = ADC1BUF8;
0003A2  801880     MOV ADC1BUF8, W0
0003A4  888590     MOV W0, 0x10B2
154:                   adc_buffer[9] = ADC1BUF9;
0003A6  801890     MOV ADC1BUF9, W0
0003A8  8885A0     MOV W0, 0x10B4
155:                   adc_buffer[10] = ADC1BUFA;
0003AA  8018A0     MOV ADC1BUFA, W0
0003AC  8885B0     MOV W0, 0x10B6
156:                   adc_buffer[11] = ADC1BUFB;
0003AE  8018B0     MOV ADC1BUFB, W0
0003B0  8885C0     MOV W0, 0x10B8
157:                   adc_buffer[12] = ADC1BUFC;
0003B2  8018C0     MOV ADC1BUFC, W0
0003B4  8885D0     MOV W0, 0x10BA
158:                   adc_buffer[13] = ADC1BUFD;
0003B6  8018D0     MOV ADC1BUFD, W0
0003B8  8885E0     MOV W0, 0x10BC
159:                   adc_buffer[14] = ADC1BUFE;
0003BA  8018E0     MOV ADC1BUFE, W0
0003BC  8885F0     MOV W0, 0x10BE
160:                   adc_buffer[15] = ADC1BUFF;
0003BE  8018F0     MOV ADC1BUFF, W0
0003C0  888600     MOV W0, 0x10C0
161:                   
162:                   
163:                   data_ready = true;
0003C2  B3C010     MOV.B #0x1, W0
0003C4  B7F0A0     MOV.B WREG, data_ready
164:                   
165:                   // clear the ADC interrupt flag
166:                   IFS0bits.AD1IF = false;
0003C6  A9A801     BCLR 0x801, #5
167:               }
0003C8  FA8000     ULNK
0003CA  F90034     POP DSWPAG
0003CC  F90032     POP DSRPAG
0003CE  78004F     MOV [--W15], W0
0003D0  064000     RETFIE
168:               
169:               uint16_t* ADC1_GetBufferPtr(void) {
000A30  FA0000     LNK #0x0
170:                   return &adc_buffer;
000A32  210A20     MOV #0x10A2, W0
171:               }
000A34  FA8000     ULNK
000A36  060000     RETURN
172:               
173:               bool ADC1_IsDataReady(void) {
000A38  FA0000     LNK #0x0
174:                   return data_ready;
000A3A  BFD0A0     MOV.B data_ready, WREG
175:               }
000A3C  FA8000     ULNK
000A3E  060000     RETURN
176:               
177:               void ADC1_AcknowledgeDataReady(void) {
000A40  FA0000     LNK #0x0
178:                   data_ready = false;
000A42  EF70A0     CLR.B data_ready
179:               }
000A44  FA8000     ULNK
000A46  060000     RETURN
180:               
181:               /**
182:                 End of File
183:               */
